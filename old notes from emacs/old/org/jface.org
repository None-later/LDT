  ATK_ROLE_ACCEL_LABEL,      /*<nick=accelerator-label>*/
  ATK_ROLE_ALERT,
  ATK_ROLE_ANIMATION,
  ATK_ROLE_ARROW,
  ATK_ROLE_CALENDAR,
  ATK_ROLE_CANVAS,
  ATK_ROLE_CHECK_BOX,
  ATK_ROLE_CHECK_MENU_ITEM,
  ATK_ROLE_COLOR_CHOOSER,
  ATK_ROLE_COLUMN_HEADER,
  ATK_ROLE_COMBO_BOX,
  ATK_ROLE_DATE_EDITOR,
  ATK_ROLE_DESKTOP_ICON,
  ATK_ROLE_DESKTOP_FRAME,
  ATK_ROLE_DIAL,
  ATK_ROLE_DIALOG,
  ATK_ROLE_DIRECTORY_PANE,
  ATK_ROLE_DRAWING_AREA,
  ATK_ROLE_FILE_CHOOSER,
  ATK_ROLE_FILLER,
  ATK_ROLE_FONT_CHOOSER,
  ATK_ROLE_FRAME,
  ATK_ROLE_GLASS_PANE,
  ATK_ROLE_HTML_CONTAINER,
  ATK_ROLE_ICON,
  ATK_ROLE_IMAGE,
  ATK_ROLE_INTERNAL_FRAME,
  ATK_ROLE_LABEL,
  ATK_ROLE_LAYERED_PANE,
  ATK_ROLE_LIST,
  ATK_ROLE_LIST_ITEM,
  ATK_ROLE_MENU,
  ATK_ROLE_MENU_BAR,
  ATK_ROLE_MENU_ITEM,
  ATK_ROLE_OPTION_PANE,
  ATK_ROLE_PAGE_TAB,
  ATK_ROLE_PAGE_TAB_LIST,
  ATK_ROLE_PANEL,
  ATK_ROLE_PASSWORD_TEXT,
  ATK_ROLE_POPUP_MENU,
  ATK_ROLE_PROGRESS_BAR,
  ATK_ROLE_PUSH_BUTTON,
  ATK_ROLE_RADIO_BUTTON,
  ATK_ROLE_RADIO_MENU_ITEM,
  ATK_ROLE_ROOT_PANE,
  ATK_ROLE_ROW_HEADER,
  ATK_ROLE_SCROLL_BAR,
  ATK_ROLE_SCROLL_PANE,
  ATK_ROLE_SEPARATOR,
  ATK_ROLE_SLIDER,
  ATK_ROLE_SPLIT_PANE,
  ATK_ROLE_SPIN_BUTTON,
  ATK_ROLE_STATUSBAR,
  ATK_ROLE_TABLE,
  ATK_ROLE_TABLE_CELL,
  ATK_ROLE_TABLE_COLUMN_HEADER,
  ATK_ROLE_TABLE_ROW_HEADER,
  ATK_ROLE_TEAR_OFF_MENU_ITEM,
  ATK_ROLE_TERMINAL,
  ATK_ROLE_TEXT,
  ATK_ROLE_TOGGLE_BUTTON,
  ATK_ROLE_TOOL_BAR,
  ATK_ROLE_TOOL_TIP,
  ATK_ROLE_TREE,
  ATK_ROLE_TREE_TABLE,
  ATK_ROLE_UNKNOWN,
  ATK_ROLE_VIEWPORT,
  ATK_ROLE_WINDOW,
  ATK_ROLE_HEADER,
  ATK_ROLE_FOOTER,
  ATK_ROLE_PARAGRAPH,
  ATK_ROLE_RULER,
  ATK_ROLE_APPLICATION,
  ATK_ROLE_AUTOCOMPLETE,
  ATK_ROLE_EDITBAR,          /*<nick=edit-bar>*/
  ATK_ROLE_EMBEDDED,
  ATK_ROLE_ENTRY,
  ATK_ROLE_CHART,
  ATK_ROLE_CAPTION,
  ATK_ROLE_DOCUMENT_FRAME,
  ATK_ROLE_HEADING,
  ATK_ROLE_PAGE,
  ATK_ROLE_SECTION,
  ATK_ROLE_REDUNDANT_OBJECT,
  ATK_ROLE_FORM,
  ATK_ROLE_LINK,
  ATK_ROLE_INPUT_METHOD_WINDOW,
  ATK_ROLE_TABLE_ROW,
  ATK_ROLE_TREE_ITEM,
  ATK_ROLE_DOCUMENT_SPREADSHEET,
  ATK_ROLE_DOCUMENT_PRESENTATION,
  ATK_ROLE_DOCUMENT_TEXT,
  ATK_ROLE_DOCUMENT_WEB,
  ATK_ROLE_DOCUMENT_EMAIL,
  ATK_ROLE_COMMENT,
  ATK_ROLE_LIST_BOX,
  ATK_ROLE_GROUPING,
  ATK_ROLE_IMAGE_MAP,
  ATK_ROLE_NOTIFICATION,
  ATK_ROLE_INFO_BAR,
  ATK_ROLE_LEVEL_BAR,
  ATK_ROLE_TITLE_BAR,
  ATK_ROLE_BLOCK_QUOTE,
  ATK_ROLE_AUDIO,
  ATK_ROLE_VIDEO,
  ATK_ROLE_DEFINITION,
  ATK_ROLE_ARTICLE,
  ATK_ROLE_LANDMARK,
  ATK_ROLE_LOG,
  ATK_ROLE_MARQUEE,
  ATK_ROLE_MATH,
  ATK_ROLE_RATING,
  ATK_ROLE_TIMER,
  ATK_ROLE_DESCRIPTION_LIST,
  ATK_ROLE_DESCRIPTION_TERM,
  ATK_ROLE_DESCRIPTION_VALUE,
  ATK_ROLE_STATIC,
  ATK_ROLE_MATH_FRACTION,
  ATK_ROLE_MATH_ROOT,
  ATK_ROLE_SUBSCRIPT,
  ATK_ROLE_SUPERSCRIPT,
  ATK_ROLE_LAST_DEFINED

#+STARTUP: showeverything
* Parent file:
[[file:eclipse.org][eclipse]]

* About
Vogella tutorial:
http://www.vogella.com/tutorials/EclipseJFace/article.html

* Theory
- Thin layer on top of SWT.
Provides
 - automatic resourse mangement
 - Viewers
   - Viewers consist of a 'model' + 'viewer', to
     seperate data and the viewer.
* JFace Standalone projects
To use JFace on it's own, import dependent projects:
 - org.eclipse.jface        (Platform Ui)
 - org.eclipse.jface.databinding (Platform Ui)
 - org.eclipse.swt   (SWT)  [or use jar]
* JFace Snippets
https://wiki.eclipse.org/index.php/JFaceSnippets

Also:
org.eclipse.jface.snippets
* Resource Manager
** About
Colors / fonts / images are not auto garbage collected by parent
composite.
           o
*LocalResourceManager* provides garbage collection support.

A resource manager is created with a reference to a composite. When
the composite is\disposed, the local resource manager is disposed with it.
** Example:
#+BEGIN_SRC java
// create the manager and bind to a widget
LocalResourceManager resManager =
  new LocalResourceManager(JFaceResources.getResources(), composite);
// create resources
Color color = resManager.createColor(new RGB(200, 100, 0));
Font font = resManager.
  createFont(FontDescriptor.createFrom("Arial", 10, SWT.BOLD));
// get an imageDescriptor and create Image object
Image image = resManager.createIma.e(imageDescriptor);
#+END_SRC

** Getting img descriptor
createImage() accepts an *ImageDescriptor* class. To get img descriptor:
#+BEGIN_SRC java
  Bundle bundle = FrameworkUtil.getBundle(this.getClass());
  // use the org.eclipse.core.runtime.Path as import
  URL url = FileLocator.find(bundle,
      new Path("icons/alt_window_32.gif"), null);
  ImageDescriptor imageDescriptor = ImageDescriptor.createFromURL(url);
#+END_SRC
* ControlDecorator (tooltips)
Decorate some control with tooltip:
#+BEGIN_SRC java
// create the decoration for the text UI component
final ControlDecoration deco =
 new ControlDecoration(text, SWT.TOP | SWT.RIGHT);

// re-use an existing image
Image image = FieldDecorationRegistry.
  getDefault().
  getFieldDecoration(FieldDecorationRegistry.DEC_INFORMATION).
  getImage();
// set description and image
deco.setDescriptionText("This is a tooltip text");
deco.setImage(image);
// hide deco if not in focus
deco.setShowOnlyOnFocus(true);
#+END_SRC

You can manually show/hide the deco via:
deco.hide();
deco.show();
* Content Assist
~org.eclipse.jface.fieldassist~ package provides user-input help for widget.
 e.g for text field or combo. Get a preview when pressing '.' or '#'.
[[http://www.vogella.com/tutorials/EclipseJFace/article.html#d234491e194][See details]]

Looks like this:
[[./img_jface.org/img_2015_01_28__10_55_40.png]]

See example: [[*EG__%20Content%20Assist][example]]
* Eclipse JFace Viewers
** About
*** Purpose
Seperate data & ui.

Viewer allos you to set a /content provider/ which provides data for viewer. (makes no assumptions about presentation).

/label provider/ can be assigned to a viewer. (expresses how data is to be displayed)
*** Standard JFace Viewer
Common viewers:
org.eclipse.jface.viewers
- ComboViewer
- ListViewer
- TreeViewer
- TableViewer

*** Contentent Providers
Interfaces for content providers:
| Class                      | Description                                                          |
|----------------------------+----------------------------------------------------------------------|
| IStructuredContentProvider | for List-/Combo-/TableViewer. Jface provides default implementations |
|                            | for Collections and arrays with the *ArrayContentProvider* class     |
|----------------------------+----------------------------------------------------------------------|
| ITreeContentProvider       | for TreeViewer class.                                                |

Note: *ArrayContentProvider* can be shared via ArrayContentProvider.getInstance(), as it does not hold data.
*** Label Providers

| Required class    | Stanrd Label providers | Description                                                  |
|-------------------+------------------------+--------------------------------------------------------------|
| ILabelProvider    | LabelProvider          | Used for lists, trees. Can return icon and label per element |
| CellLabelProvider | ColumnLabelProvider    | For tables. Defines label per column.                        |

** JFace Combo Viewer
   see [fn:eg_comb_viewer]

* Data Binding
[[http://www.vogella.com/tutorials/EclipseDataBinding/article.html][src]]

This involves adding change listeners to

** Java Bean object
 - setter/getter

 - PropertyChangeSupport & propogate to listeners


* Dialogs

MessageDialog.openConfirm(shell, "Confirm", "Please confirm");
MessageDialog.openError(shell, "Error", "Error occured");
MessageDialog.openInformation(shell, "Info", "Info for you");
MessageDialog.openQuestion(shell, "Question", "Really, really?");
MessageDialog.openWarning(shell, "Warning", "I am warning you!");


* Examples (functional)
** EG__ Content Assist
[[./img_jface.org/img_2015_01_28__11_09_47.png]]
#+BEGIN_SRC java
import org.eclipse.jface.bindings.keys.KeyStroke;
import org.eclipse.jface.bindings.keys.ParseException;
import org.eclipse.jface.fieldassist.ContentProposalAdapter;
import org.eclipse.jface.fieldassist.ControlDecoration;
import org.eclipse.jface.fieldassist.FieldDecorationRegistry;
import org.eclipse.jface.fieldassist.SimpleContentProposalProvider;
import org.eclipse.jface.fieldassist.TextContentAdapter;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.ModifyEvent;
import org.eclipse.swt.events.ModifyListener;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Text;

public class main {

	public static void main (String [] args) {
		// LTD Auto-generated method stub
		final Shell shell = new Shell ();
		Composite parent = shell;
//		shell.setLayout (new RowLayout ());

		GridLayout layout = new GridLayout (2, false);
		// parent is a Composite
		parent.setLayout (layout);
		Label lblPleaseEnterA = new Label (parent, SWT.NONE);
		lblPleaseEnterA.setText ("Please enter a value:");

		Text text = new Text (parent, SWT.BORDER);
		GridData gd_text = new GridData (SWT.FILL, SWT.CENTER, true, false);
		gd_text.horizontalIndent = 8;
		text.setLayoutData (gd_text);
		GridData data = new GridData (SWT.FILL, SWT.TOP, true, false);
		text.setData (data);

		// create the decoration for the text component
		final ControlDecoration deco = new ControlDecoration (text, SWT.TOP | SWT.LEFT);

		// use an existing image
		Image image = FieldDecorationRegistry.getDefault ()
				.getFieldDecoration (FieldDecorationRegistry.DEC_INFORMATION).getImage ();

		// set description and image
		deco.setDescriptionText ("Use CNTL + SPACE to see possible values");
		deco.setImage (image);

		// always show decoration
		deco.setShowOnlyOnFocus (false);

		// hide the decoration if the text component has content
		text.addModifyListener (new ModifyListener () {

			@Override
			public void modifyText (ModifyEvent e) {
				Text text = (Text) e.getSource ();
				if (!text.getText ().isEmpty ()) {
					deco.hide ();
				} else {
					deco.show ();
				}

			}
		});

		// help the user with the possible inputs
		// "." and "#" activate the content proposals
		char [] autoActivationCharacters = new char [] { '.', '#' };
		KeyStroke keyStroke;
		//
		try {
			keyStroke = KeyStroke.getInstance ("Ctrl+Space");
			ContentProposalAdapter adapter = new ContentProposalAdapter (
					text,
					new TextContentAdapter (),
					new SimpleContentProposalProvider (new String [] { "ProposalOne", "ProposalTwo", "ProposalThree" }),
					keyStroke, autoActivationCharacters);
		} catch (ParseException e1) {
			e1.printStackTrace ();
		}

		shell.open ();
		Display display = Display.getDefault ();
		while (!shell.isDisposed ())
			if (!display.readAndDispatch ())
				display.sleep ();
		display.dispose ();
	}

}
#+END_SRC
** EG__ Combo Viewer
[fn:eg_comb_viewer]
2 parts. Person Model & Combo viewer.
Preview:
[[./img_jface.org/img_2015_01_28__11_40_38.png]]
*** Person:
#+BEGIN_SRC java
public class Person {
	private String firstName;
	private String lastName;
	private boolean married;

	public Person (String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	public String getFirstName () {
		return firstName;
	}

	public void setFirstName (String firstName) {
		this.firstName = firstName;
	}

	public String getLastName () {
		return lastName;
	}

	public void setLastName (String lastName) {
		this.lastName = lastName;
	}

	public boolean isMarried () {
		return married;
	}

	public void setMarried (boolean married) {
		this.married = married;
	}
}
#+END_SRC
*** Combo Viewer:
#+BEGIN_SRC java
import org.eclipse.jface.viewers.ArrayContentProvider;
import org.eclipse.jface.viewers.ComboViewer;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Shell;

public class ComboViewerMAIN {

	public static void main (String [] args) {
		// LTD Auto-generated method stub
		final Shell shell = new Shell ();
		Composite parent = shell;

		// the following code is executed by the method which
		// creates the user interface
		// assumes parent is a SWT Composite

		GridLayout layout = new GridLayout (2, false);
		parent.setLayout (layout);

		Label label = new Label (parent, SWT.NONE);
		label.setText ("Select a person:");
		final ComboViewer viewer = new ComboViewer (parent, SWT.READ_ONLY);

		// the ArrayContentProvider  object does not store any state,
		// therefore you can re-use instances
		viewer.setContentProvider (ArrayContentProvider.getInstance ());
		viewer.setLabelProvider (new LabelProvider () {
			@Override
			public String getText (Object element) {
				if (element instanceof Person) {
					Person person = (Person) element;
					return person.getFirstName ();
				}
				return super.getText (element);
			}
		});

		Person [] persons = new Person [] { new Person ("Lars", "Vogel"), new Person ("Tim", "Taler"),
				new Person ("Jim", "Knopf") };

		// set the input of the Viewer,
		// this input is send to the content provider

		viewer.setInput (persons);

		// You can register a listener which is notified whenever the selection of
		// the viewer changes via the following code.
		// React to the selection change of the viewer
		// note that the viewer returns the actual object
		viewer.addSelectionChangedListener (new ISelectionChangedListener () {
			@Override
			public void selectionChanged (SelectionChangedEvent event) {
				IStructuredSelection selection = (IStructuredSelection) event.getSelection ();
				if (selection.size () > 0) {
					System.out.println (((Person) selection.getFirstElement ()).getLastName ());
				}
			}
		});

		//----------------- Selection.
		// you can select an object directly via the domain object
		Person person = persons [0];
		viewer.setSelection (new StructuredSelection (person));

		// retrieves the selection, returns the data model object
		IStructuredSelection selection = (IStructuredSelection) viewer.getSelection ();
		Person p = (Person) selection.getFirstElement ();


		shell.pack ();
		shell.open ();
		Display display = Display.getDefault ();
		while (!shell.isDisposed ())
			if (!display.readAndDispatch ())
				display.sleep ();
		display.dispose ();
	}

}
#+END_SRC

* Footnotes	   







