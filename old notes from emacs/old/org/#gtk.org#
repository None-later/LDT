OFF: #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org.css" />
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2
#+SETUPFILE: ~/git/org-html-themes/setup/theme-readtheorg.setup

* About 
My notes on GTK only.
** Version info of gtk
*** Getting gtk version from bash 
//Iqn TERMINAL:
#+begin_src sh
pkg-config --modversion gtk+-3.0 
#+end_src
E.g out:
// 3.10.9  << e.g fedora 20
//3.14.5   << e.g fedora 20 

May need to install first gtk+ and gtk3 packages.
gtk3-devel

*** See also 
Version info in Swt/Fedra [[id:a5c7fcf0-377b-404c-9de6-52f94f31c1c4][link to swt-dev]]
* Getting help 
Check out resources on : http://www.gtk.org/development.php

E.g 
Irc: Channel: irc.gnome.org     channel: #gtk+
* Compiling gtk apps
Standard Compile:
gcc `pkg-config --cflags gtk+-3.0` -o main main.c `pkg-config --libs gtk+-3.0`

See also: [[id:41713989-262b-4205-bd1d-f2ecd43e71bb][@ Make and Makefiles]]
* Widget Hierarchy Diagram
[[./dot/gtkWidgetDiagram.dot]]
[[./dot/gtkWidgetDiagram.png]]
* Widget Notes
** GtkWidget
*** Window
Widget can set to have a window. This is useful so that GdkWindow can be used
on this widget.
: GdkWindow * gtk_widget_get_window (GtkWidget *widget);   //#Window #Widget
: gboolean gtk_widget_get_has_window (GtkWidget *widget);  //#Window #widget
: void gtk_widget_set_has_window (GtkWidget *widget, gboolean has_window); #Window #widget

*** Functions
  #include <gtk/gtkwidget.h>

- Realizing / Mapping / showing ::
  void gtk_widget_realize(GtkWidget* widget );
  void gtk_widget_unrealize(GtkWidget* widget );
  void gtk_widget_map(GtkWidget* widg.t );
  void gtk_widget_unmap(GtkWidget* widget );
  void gtk_widget_show(GtkWidget* widget );
  void gtk_widget_hide(GtkWidget* widget );
  GTK_WIDGET_NO_WINDOW( widget );
  GTK_WIDGET_REALIZED( widget );
  GTK_WIDGET_MAPPED( widget );
  GTK_WIDGET_VISIBLE( widge. );
  See: [[id:d37af15c-1496-4cba-9228-5404e43fbc3c][Widget States]]
** GtkContainer
*** Child traversal
**** gtk_container_forall(..) :: traverse all (internal) children.
Traverses all childern, calls callback on each one.
In contrast, gtk_container_foreach() travreses non-internal children.
**** gtk_container_foreach(..) :: traverse all (non-internal) children.
** GtkTree
*** Components 
Tree is an MVC.
 - model :: stores data (stings/ints etc..)
 - view :: told which data to display, where and how. 

GtkTreeView - The whole tree. 
                   
  GtkTreeViewColumn - A single col 
             +-------------+----------------------+
             | Column      |                      |         
             +-------------+----------------------+         
             |             |                      |         
             |             |                      |         
             +-------------+                      |         
       +-----+ A Cell      |                      |         
       |     +-------------+                      |         
       |     |             |                      |         
       |     |             |                      |         
       |     +-------------+----------------------+
       |
       +GtkCellRenderer - can hold one or many rendererers.
            |- GtkCellRendererText
            |- GtkCellRendererPixBuf 
            |- etc.. 
E.g
[[./img/img_2015_06_16__13_07_26.png]]
src: http://scentric.net/tutorial/sec-treeviewcol-renderer.html#sec-renderer
*** Cell Renderers 
- Are GObjects (not widgets). 
- have properties:
  - attributes  (e.g background/font style). 
  - cell data functions 
- *Are not single cells* 
  A CellRenderer can have multiple rows of text.


- Types :: 
  - GtkCellRendererText  :: strings/booleans  "true". 
       can have 'editable' property.
  - GtkCellRendererPixbuf :: Images. (stock or user defined)
  - GtkCellRendererToggle :: checkbox/radio

- not a cell-renderer, but a cell ::
  - GtkCellEditable :: implements GtkEntry / GtkSpinButton in a treeview.

- Derived classes inherit properties/attributes from parent classes.
*** Attributes
Set to value when redered:                          attribute / column
: gtk_tree_view_column_add_attribute(col, renderer, "text", COL_FIRST_NAME);
 Only accepts attribute, not value.

Set to value right away:
: g_object_set(....."foreground-gdk", gdkColorPtr,..) 
    takes attribute + value

*** Signals
  - row-activated :: double click on a row.
*** References
Good tree book/tutorial:
http://scentric.net/tutorial/treeview-tutorial.html

Wiki book on trees:
http://en.wikibooks.org/wiki/GTK%2B_By_Example/Tree_View/Events#Double-Clicks_on_a_Row
* Widget States and Properties
** Widget States (gtk)
Gtk states are defined in gtkenums.h 
#+BEGIN_SRC c
typedef enum
{
  GTK_STATE_NORMAL,
  GTK_STATE_ACTIVE, //e.g depressed button
  GTK_STATE_PRELIGHT, //mouse pointer over widget
  GTK_STATE_SELECTED, //selected item. e.g a row item.n
  GTK_STATE_INSENSITIVE, //un responsive to actions.
  GTK_STATE_INCONSISTENT, //e.g radio buttons that are neither true or false.
  GTK_STATE_FOCUSED
} GtkStateType;
#+END_SRC
** Sensitivity
A widget is sensitive if a user can interact with it. [[https://developer.gnome.org/gtk3/stable/GtkWidget.html#gtk-widget-set-sensitive][reference]]
** Alignment / justification
*** About
In gtk3 one has to be careful about alignment.

Main article:          WWW__ alignment 
http://www.murrayc.com/permalink/2015/03/02/gtk-aligning-justification-in-text-widgets/
*** Alignment & Justification in general
They are different. 
- Alignmen ::  
  Is like align to a column, like this sentence is aligned to it's heading.
  Often a value of a column, or float like 0.2

- Justification ::
  Is often about attaching to borders:
  | This    sentence    is  left    and   right   justified|
  
  Often value is "left,right"

More info:  [[http://en.wikipedia.org/wiki/Typographic_alignment][wiki typography]]
*** Alignment & Justification in Gtk3
In gtk, these are sometimes confused.

There are 3 Gtk+ Text widgets: GtkEntry, GtkTextView, GtkLabel

- Defaults ::
  GtkLabel
   Single line - Centered 
   Multi line  - Left aligned, wrap.

  GtkTextView
   Single line - Left aligned, wrap
   Multi line  - Left aligned

  GtkEntry - left aligned

- Justification :: 
   Label: 
     Single line : *no effect*
     Multi line  : justification observed 

   GtkTextview 
     Single/multi line 

   GtkEntry  *(has no justification functions)*   
     

    [[https://developer.gnome.org/gtk3/stable/GtkLabel.html#gtk-label-set-justify][gtk_label_set_justify()]] On Labels
    [[https://developer.gnome.org/gtk3/stable/GtkTextView.html#gtk-text-view-set-justification][gtk_text_view_set_justification()]] on the GtkTextViews,    gtk_text_view_set_wrap_mode() on for that to take effect. 

    E.g right justification:
    [[http://www.murrayc.com/blog/wp-content/uploads/2015/03/screenshot_test_gtk_text_widgets_justify.png]]

- Justification & widget_set_halign ::
  This imacts the whole widget, not just the text.
  E.g: http://www.murrayc.com/blog/wp-content/uploads/2015/03/screenshot_test_gtk_text_widgets_halign_and_justify_with_background.pngn

- gtk_label_set_xalign ::
  Justification and widget_set_halign did not play well together as halign messed with the whole
  widget.
  Gtk devs noticed this, and they [[https://bugzilla.gnome.org/show_bug.cgi?id%3D735841#c3][added]] [[https://developer.gnome.org/gtk3/unstable/GtkLabel.html#gtk-label-set-xalign][gtk_label_set_xalign()]].

  It aligns text, not the widget.
  
- entry alignment ::
  [[https://developer.gnome.org/gtk3/unstable/GtkEntry.html#gtk-entry-set-alignment][gtk_entry_set_alignment()]], aligns the text in the widget, not the widget itself.


- Conclusion ::
  To justify only the *text* :
  GtkLabel: 
    gtk_label_set_xalign()  / gtk_misc_set_alignment() for pre 3.16
    gtk_label_set_justify()

  GtkTextView:
    gtk_text_view_set_justification()
    gtk_text_view_set_wrap_mode()  << use with

  GtkEntry:
    gtk_entry_set_alignment()
  
** Colors (GdkColor & GdkRGBA)
:PROPERTIES:
:ID:       59b7183d-b6a2-4441-8169-4839a7f8702b
:END:
*** GdkColor vs GdkRGBA 
GdkColor has been deprecated in Gtk3.14
GdkRGBA  was introduced in Gtk3.0

Many functions that relied on GdkColor, now utilize GdkRGBA alternatives.
*** GdkColor (Deprecated in 3.14)
#+BEGIN_SRC c++
typedef struct {
   guint32 pixel; //Intensity of light. 0= no light/dark.
   guint16 red;
   guint16 green;
   guint16 blue;
 } GdkColor;
#+END_SRC
Note: [[http://homepages.inf.ed.ac.uk/rbf/HIPR2/value.htm][Glossary - Pixel Values]]
*** GdkRGBA (since 3.0)
#+BEGIN_SRC c++
typedef struct {
  gdouble red;
  gdouble green;
  gdouble blue;
  gdouble alpha; //0 = translucent. 1 = opaque.
} GdkRGBA;
#+END_SRC
*** Setting foreground color
E.g setting the label text color:

#+BEGIN_SRC c++
//Gtk2
 GdkColor color;
 ..
 gtk_widget_modify_fg (label, GTK_STATE_NORMAL, &color);

//Gtk3
  GdkRGBA rgbaColor;
  ...
  gtk_widget_override_color(label, GTK_STATE_FLAG_NORMAL, &rgbaColor);
#+END_SRC

*** Examples 
[[id:8af4a1e7-81ce-41cb-8196-6a3991c2ed30][GdkColor]]
[[id:64e4de34-de11-44a7-a326-1d26219f9500][GdkRGBA]
* Themeing 
:PROPERTIES:
:ID:       018c57bf-2db9-44d2-91dc-cda37fd6aa53
:END:
** Theory of themeing in Gtk3.
*** 10,000 ft overview
#+BEGIN_SRC dot :file ./img/img_2015_03_23__15_18_57.png :cmdline -Kdot -Tpng
digraph {
a,b,c,d [shape=box]
a [label="Gtk Applications"]
b [label="Set of widgets"]
c [label="Drawing functions"]
d [label="GTK Engines"]
a -> b
b -> c 
c -> d [label=" overriden by themes"]
}
#+END_SRC

#+results:
[[file:./img/img_2015_03_23__15_18_57.png]]

*** Gtk2 Theming
- Engines :: 
  - implement the gtk_paint_* methods
  - custom engine-specific rendering properties
  - access to the GtkWidget -> powerful

- GtkRC ::
  Custom text format to describe and configure Gtk2 options
  - Style Classes
  - set widget properties and engine custom rendering properties
  - class/widget_class/widget name matchers
  - assosiation matchers -> style classes 

- Gtk2 Problems ::
  - GtkRC syntax limited and not expressive.
  - dozens of very specialized different engines.
  - modifying an engine is difficult (C code)..
  - No standard way to render a desired effect.
  - No standard way of testing regression.
  - Accessing gtk internals from engine.
  - Weak seperation between content and presentation. 
*** CSS
- Universal Language ::
  - W3C Standard
  - Seperate content & presentation.
  - nativley supports a large subset of GtkRC
  - No need to worry if feature is supported by specific engine
  - Well maintained standard

- Clear Semantics :: 
  - sytle property semantics are predictable and can be tested (reftests)
  - CSS Box Model (padding, margin, border)
  - inheritence 
  - font properties 
  - shorthand properties

- Cool effects :: 
  - border-image 
  - text-shadow
  - gradient support (not yet formalized by W3C, supported as -gtk-gradient in Gtk).

- Interntal & External ::
  - CSS can be in the code, or come as seperate file.  
  - External CSS doesn't require re-compilation of the program.  
  - Easier for other people who don't know your code to style your app.  
*** Gtk3 Theming 
- GtkStyleContext :: 
  GtkStyleContext -> GtkStyle on sterioids.
  - Application side interface to drawing and theming.
  - each widget holds it's own different context.
  - independent from GtkWidget, operates on /GtkWidgetPath/ structure.
  - /GtkWidgetPath/ contains info for generic toplevel -> child widget hierarhiecs.
  - easy styling for foreing toolkits (WebKit, QT, ..)

- Style classes ::       /.scrollbar =  (.slider + .through + .button)/
  - Conceptually decompose a widget in a set of one or more base elements. E.g: 

  - apply a style to each base widget element
  - same widget -> lots of possibilities without touching code: 
    .toolbar vs .primary-toolbar

- Widget Regions ::     /GtkTreeView -> row,column,column-header/
  - number of repeated elements in a type not known.
  - named class + set of order-based flags:  
    even, odd, first, last, sorted
  - use /n-th/ child to match desired flag from the CSS

- Native n-th child support in containers ::
  - Construct a selector matching the position of an element relative to it's siblings.
  - Works by default for widgets packed into *GtkBox* and *GtkToolBar*

- Animatable Regions ::
  - get/set style propreties as GtkStyle used to GtkStyleContext conuterparts.  
  - calls into cario to do the actual rendering.  

- Theme side counterpart of GtkStyleContex ::
  - default implementation inside GTK+.
  - external theming engine ==   (subclass + .so module library).
  - no access to gtk internals.
  - access to all style information stored inside GtkStyleContext
  - register custom style properties.

- Writing theme engines :: 
  - In general, you should not have to write theming engines unless you know what
    you are doing.
  - You should be able to do everything you need with CSS and SVG.

- Currently missing ::
  - multi-layerd backgrounds.
  - inconsistent focus themeing properties
  - not possible to render outside gtk rendex box.
  - But, adwaina is now 90% CSS.

- Application vs Centralised theming :: 
  - Should applications or rendering engines specify CSS?
  - → Theme knows better unless app really needs special look.
  - Hardcoded colors in app make apps unthemeble.
  - Try to be more CSS focused, design app with CSS in mind.

- Future ::
  - drop Raleigh as default GTK theme (!?).  
  - multiple background composition.  
** Code
** UMl Class Relations
:PROPERTIES:
:END:
#+BEGIN_SRC dot :file ./img/img_2015_03_27__16_18_00.png :cmdline -Kdot -Tpng
digraph {
size=9
node[shape=record,style=filled,fillcolor=gray95 width=.2]
edge[dir=back, arrowtail=empty]

GtkStyleContext [label="{GtkStyleContext|Stores styling info}"]
GtkCssProvider [label="{GtkCssProvider|Parses raw css}"]
GtkStyleProvider [label="{GtkCssProvider|get value of attribute}"]

GBoxed -> {GtkCssSection GtkBorder}
GObject -> {GtkCssProvider GtkStyleContext GtkIconTheme}
GInterface -> {GtkStyleProvider}
GtkStyleProperties [label="{\<\<Interface\>\>|GtkStyleProperties|(mostly deprecated)}"]
GtkWidgetPath [label="{GtkWidgetPath}"]

GtkStyleProperties -> GtkCssSection [style=dotted]

GtkCssProvider -> GtkStyleContext [dir=none style=dotted]
GtkWidgetPath -> GtkStyleContext [dir=none style=dotted label="WP used by SC"] 
GtkStyleProvider -> GtkStyleContext [dir=none style=dotted label="provide style info to SC"]

}
#+END_SRC

#+results:
[[file:./img/img_2015_03_27__16_18_00.png]]

:PROPERTIES:
:ID:       cc91c1f9-7b5e-45d4-8d16-c69a2b9de46c
:END:
** UML Class Details
#+BEGIN_SRC plantuml :file ./img/img_2015_03_27__11_52_45.png
' Non-class elements 
class theme as "Gtk Theming"
hide theme circle
hide theme fields
hide theme methods

class styling as "Styling classes"
hide styling circle
hide styling fields
hide styling methods

theme --> styling 

'''''''' Styling elements 
class GtkStyleContext {
.. context .. 
gtk_style_context_*()
  *_[new|get] () //context
  *_[get|set]_parent ()
  *_[get|set]_path ()
  *_get_style()
  *_get_style_property()
  *_get_padding()
  etc ... ()
  *_add_provider ()
  *_get_background_color () //deprecated
  *_set_background()
  *_[add|remove]_class ()
.. border ..
gtk_border_[new|copy|free] () 
.. render .. 
gtk_render_* ()
*_arrow ()
*_background ()
*_check ()
*_expander ()
*_focus () 
*_frame ()  //border around an element.
*_handle () // something to gab onto,
*_option () //radio button
__ Style Properties __ 
GTK_STYLE_PROPERTY_*
background-color
background-image
color
font
margin
padding
border-[width|radius|style|color]
__ Style Classes __ 
GTK_STYLE_CLASS_*
accelerator 
arrow
background  //window background
bottom
button  //for button and subclasses
calendar //not used by gtk+ itself.
cell  //tree view
combobox-entry
context-menu
check // GtkCheckButton, GtkCheckMenu ..
dnd   //dnd indicator
entry //gtkEntry
error //GtkInfoBar
frame  //GtkFrame/GtkScrollbar
flat
image //e.g icon in entry
label // Gtk3.16  GtkLabel 
notebook
scrollbar //see also 'frame'
scrollbar-junction
spinbutton
}


class GtkStyleProperties {
  <b>Mostly deprecated</b>
}

class GtkStyleProvider { 
  GtkIconFactory * 	gtk_style_provider_get_icon_factory ()
  GtkStyleProperties * 	gtk_style_provider_get_style ()
   gboolean 	gtk_style_provider_get_style_property ()
}

styling --> GtkStyleContext
styling --> GtkStyleProperties
styling --> GtkStyleProvider


' CSS & widget path bits
class CssProvider { 
-- Provider -- 
gtk_css_provider_*
*_new ()
*_to_string ()
*_get_default ()
*_get_named () 
*_load_from_data ()
*_load_from_file ()
*_load_from_path ()
*_load_from_resource ()
-- Section --
gtk_css_section_*
*_get_end_line ()
..
*_get_start_position () 
*_section_ref ()
*_section_unref () 
}

class WidgetPath { 
 See :  gtk_widget_get_path()
}

theme --> CssProvider
theme --> WidgetPath

class GtkIconTheme {
 Provide icons by name 
--

}

theme --> GtkIconTheme

#+END_SRC
#+results:
[[file:./img/img_2015_03_27__11_52_45.png]]
** GtkStyleContext                                                    :GTK3:
:PROPERTIES:
:ID:       b4367994-ad0a-4f66-8c88-95928c99808c
:END:
*** About
**** Description
- purpose :: /store styling info/
  GtkStyleContext stores styling info about a widget, defined by *GtkWidgetPath*.

- Getting final style ::
  To get final style, it queries all attached *GtkStyleProviders*.

- Adding style providers :: 
  Either attach explicidly to the context via:  ~gtk_style_context_add_provider()~
  or to the screen: ~gtk_style_context_add_provider_for_screen()~.  

- gtk_widget_get_style_context() ::
  When it returns a context, it will contain the GtkWidgetPath, GdkScreen etc..
  Context is automatically updated when these change.

- Functions ::
  - make context
  - get context & parent context 
  - get properties:  Background/Color/Border/Padding
**** GtkStyle Context & other classes.
#+BEGIN_SRC dot :file ./img/img_2015_03_27__17_33_05.png :cmdline -Kdot -Tpng
digraph { 
GtkStyleContext -> GtkStyleProviders [label="Queries all it's\nProviders to get\nstyling info"]
}
#+END_SRC

#+results:
[[file:./img/img_2015_03_27__17_33_05.png]]

*** Style context struct
Below are some bits of the style context struct.  
It has info on:
 - Context
 - parent/children
 - widget path
 - style hash table 
 - CSS pending changes 
 - invalidation of context
 - others ... 
#+BEGIN_SRC c
struct _GtkStyleContextPrivate
{
  //..
  GtkStyleCascade *cascade;
  GtkStyleContext *parent;
  GSList *children;
  GtkWidget *widget;
  GtkWidgetPath *widget_path;
  GHashTable *style_data;
  GtkStyleInfo *info;

  GtkCssChange relevant_changes;
  GtkCssChange pending_changes;

  const GtkBitmask *invalidating_context;
  //...
};
#+END_SRC

*** Getting style context
#+NAME: Getting_context_for_a_button
#+BEGIN_SRC cpp
static void
gtk_button_init (GtkButton *button)
{
  GtkStyleContext *context;

  ...

  context = gtk_widget_get_style_context (GTK_WIDGET (button));

  /* Set the "button" class */
  gtk_style_context_add_class (context, GTK_STYLE_CLASS_BUTTON);
}
#+END_SRC
*** References
https://developer.gnome.org/gtk3/stable/GtkStyleContext.html
** GtkCssProvider & CSS notions:                                       :GTK3:
:PROPERTIES:
:ID:       0b505e4f-e64c-4d7d-9997-fbb9b1cfc057
:END:
*** About
Object that implements GtkStyleProvider.  

Parses CSS-like input in order to style widgets.

App can load CSS:
~gtk_css_provider_load_from_file()~

And add provider:
: gtk_style_context_add_provider()    //For widget
: gtk_style_context_add_provider_for_screen(). //For all widgets


Files read on load:
: $XDG_CONFIG_HOME/gtk-3.0/gtk.css   //primary
: datadir/share/themes/theme-name/gtk-3.0/gtk.css  //falback.
*** General syntax :  (Selectors:states,)+ { (Attribute=values;)+ }
GtkButton:focus {
  background: red;
}
*** Style sheets
General syntax follows CSS form:
#+BEGIN_SRC scheme 
<Style Sheet syntax> ::= <selectors> "{" <declarations> "}"
<selectors> ::= <selector>
              | <selector> "," <selectors> |

<selector> ::= "GtkButton" | "GtkEntry" ..etc... 

<declarations> ::= <declaration>
                | <declaration> ";" <declarations> 

<declaration> ::= <property> ":" <value>
#+END_SRC

Example:
#+BEGIN_SRC css
GtkButton, GtkEntry {   /* Selectors seperated by comma.*/
    color: #ff00ea;
    font: Comic Sans 12
}
#+END_SRC
*** Selectors, classes  & Widget States
**** About: selector.class:state { CSS }
**** Selectors
***** About
- Similar to CSS.
- Widget names should be prefixed by '#'
- '*' is universal selector.
- Combining is possible: ~GtkButton#button1~
- match widget only if it is inside another, leave *space* between them
  : GtkToolbar GtkButton      /* selects button that is inside toolbar */
  This is a deep match. To restrict to only direct children, use '>'
  : GtkNotebook > GtkLabel

- more specific rules take precedence. 
***** Examples
#+BEGIN_SRC css
  /* Label that descends from window  */
  GtkWindow GtkLabel {
      background-color: #898989
  }

 /* Theme Notebook and all within */
GtkNotebook {                 
    background-color: #a939f0 
} 

/* Theme all children of GtkBin */
GtkBin * {        
    font: Sans 20 
}                 

/* Theme a label named 'title-label' */
GtkLabel#title-label { 
    font: Sans 15      
}                      

/* Theme any widget named main-entry */
#main-entry {                 
     background-color: #f0a810 
}                             
#+END_SRC
**** Style classes
***** About
- Apply theme to existing classes or define your own class.

(!) ambiguity : string is treated as widget class name if it has an upper case letter.

Note:
- Existing classes ::
  Some classes are already defined in GTK as in html. See [[id:e4339e89-53ff-4348-ada7-32ae684d3bbe][List of available classes]]
  e.g in HTML there is 'p' for paragrpah. In Gtk there is 'entry' for entries.
***** Examples CSS
- Theme all entries ::
  #+BEGIN_SRC css
  .entry {
      color : #39f1f9;
  }
  #+END_SRC
- Theme all buttons that are focused ::
  #+BEGIN_SRC css
  .button:focus {
   background: red;
  }
  #+END_SRC
- Theme spin Button's entries ::
  #+BEGIN_SRC css
  GtkSpinButton.entry {
     color : #900185;
  }
  #+END_SRC
***** Code
****** Adding and removing css classes
******* Syntax 
  #+BEGIN_SRC c
  void gtk_style_context_add_class (GtkStyleContext *context,
                               const gchar *class_name);

  void gtk_style_context_remove_class (GtkStyleContext *context,
                                  const gchar *class_name);
  #+END_SRC
******* Examples
- Small ::
  E.g if you add 'meh' to GtkComboBoxText like:
    : gtk_style_context_add_class (button_context, "meh");

  It can be selected from global CSS via:
    :   GtkComboBoxText.meh * {
    :     ...
    :   }

- Larger :: 
  See: [[id:059d5ed7-43d0-40e6-95e7-104b11fd476e][CSS add class to widget and style from gloabl display]]

******* References
Adding class:
https://developer.gnome.org/gtk3/stable/GtkStyleContext.html#gtk-style-context-add-class

Remove class:
https://developer.gnome.org/gtk3/stable/GtkStyleContext.html#gtk-style-context-remove-class
****** List of pre-defined classes in gtk.
:PROPERTIES:
:ID:       e4339e89-53ff-4348-ada7-32ae684d3bbe
:END:
See GtkStyleContext, find the GTK_STYLE_CLASS_* macros.
E.g
  GTK_STYLE_CLASS_BUTTON
  : #define GTK_STYLE_CLASS_BUTTON "button"
  https://developer.gnome.org/gtk3/stable/GtkStyleContext.html#GTK-STYLE-CLASS-BUTTON:CAPS

  

**** CSS widget states
***** Theory
#+BEGIN_SRC bnf
GtkButton:<State> {<CSS>}

State = | focus    (persistent)
        | active   (only applicable when pressed)
        | hover    (your mouse hover over this..)
        | insensitive (when grayed out)
        | selected 
        | inconsitent 
        | ...
#+END_SRC
***** Examples
Theme active (pressed) buttons:
#+BEGIN_SRC css
GtkButton:active {
    background-color: #0274d9;
}
#+END_SRC

Other states may include: focused, selected, insensitive etc..
***** References
See more examples: https://developer.gnome.org/gtk3/stable/GtkCssProvider.html#id-1.5.3.10.5.8
*** '@' Rules : imports and color bindings
**** import other files
  Gtk supports '@ import' rule, to load other css styles
  : @import url ("path/to/common.css");
**** bind keys 
  E.g bind cursor to various actions
  #+BEGIN_SRC css
  @binding-set binding-set1 {
  bind "<alt>Left" { "move-cursor" (visual-positions, -3, 0) };
  unbind "End";
  };

  @binding-set binding-set2 {
    bind "<alt>Right" { "move-cursor" (visual-positions, 3, 0) };
    bind "<alt>KP_space" { "delete-from-cursor" (whitespace, 1)
                           "insert-at-cursor" (" ") };
  };

  GtkEntry {
    gtk-key-bindings: binding-set1, binding-set2;
  }
  #+END_SRC

**** @define-color for re-use. 
  Define name of color to be used in other places. 

- Example 1 ::
  #+BEGIN_SRC css
    @define-color bg_color #f9a039;
  ,* {
        background-color: @bg_color;
    }  
  #+END_SRC
- Example 2 ::
  #+BEGIN_SRC c++
  @define-color bg_color1 rgb (255, 0, 0);
  @define-color bg_color2 rgb (71, 71, 229);

  GtkWindow {
    background-image: -gtk-gradient (linear,
      left top,
      right bottom,
      from(@bg_color1),
      to(@bg_color2));
  }
  #+END_SRC
**** Symbolic colors (@define-color)
Can bind color to variation of existing color. 
Example : Define entry-color to be a shade of background color
#+BEGIN_SRC css
@define-color entry-color shade (@bg_color, 0.7);

GtkEntry {
    background-color: @entry-color;
}

GtkEntry:focused {
    background-color: mix (@entry-color,
                           shade (#fff, 0.5),
                           0.8);
}
#+END_SRC
*** Css Colors
**** Specifying colors (rgb etc..)
- rgb (r,g,b) :: 
  r,g,b = "0-255" | "xy%"
  e.g
  : rgb(255,0,0) | rgb(100%, 0% 0%)
- rgba(r,g,b,a) ::
  a = ? Alpha, floating point between 0 to 1 ? 
- #xxyyzz :: 
  xx , yy , zz = ? hex ditigs, 1-4 digits per component.
  : #fce   #ff00cc  #ffff0000cccc
- @name :: 
  Refer to previously named color as defined by @define-color
  : color : @bg_color;
- mix(c1,c2, factor) :: 
  linear combination of c1 & c2. 
  *factor* = float 0-1
  : color: mix(#ff1e0a, @bg_color, 0.8);
- shade (c, factor) :: 
  lighter or darker variation of color.
- lighter (color) :: 
- darker (color) :: 
- alpha (color, factor) :: 
  factor = float, 1< transparent,  >1 more opaque.
***** References
https://developer.gnome.org/gtk3/stable/GtkCssProvider.html#specifying-colors
*** Gradients 
Linear gradients can be used as background images.
**** Linear Gradients 
  #+BEGIN_SRC cpp
      -gtk-gradient (linear, 
            start_x start_y, 
            end_x end_y,
            {color-stop (position, color)}+) //one or many of these..  
  #+END_SRC
: -gtk-gradient (linear, start_x start_y, end_x end_y, {color-stop (position, color)}+)

|------------------+-------------------------------------------------------------------------|
| start_x, start_y | Are either a floating point number between 0                            |
|                  | and 1 or one of the special values 'left', 'right' or 'center'          |
|                  |                                                                         |
| end_x, end_y     | Are either a floating point number between 0 and 1 or                   |
|                  | one of the special values 'top', 'bottom' or 'center'                   |
|                  |                                                                         |
| position         | A floating point number between 0 and 1 and color is a color expression |
|                  |                                                                         |
| color-stop       | Can be repeated multiple times to add more than one color stop.         |
|------------------+-------------------------------------------------------------------------|

'from (color)' and 'to (color)' can be used as abbreviations for
                    color stops with position 0 and 1, respectively.

The *color-stop* can be repeated multiple times to add more than one color stop.
 - *from (color)* and *to (color)* can be used as abbreviations for color stops
    with position 0 and 1, respectively.

Examples
#+BEGIN_SRC c
/* yellow to blue */
-gtk-gradient (linear,
               left top, right bottom,
               from(@yellow), to(@blue));

/* Tripple color */
-gtk-gradient (linear,
               0 0, 0 1,
               color-stop(0, @yellow),
               color-stop(0.2, @blue),
               color-stop(1, #0f0))
#+END_SRC
**** Radial Gradients 

: -gtk-gradient (radial, start_x start_y, start_radius, 
:                  end_x end_y, end_radius, 
:                  {color-stop (position, color)}+)
*start_radius* and *end_radius* = float 
*others..* = see above.
See: http://developer.gnome.org/gtk3/stable/GtkCssProvider.html
**** Examples
#+BEGIN_SRC cpp
GtkWindow {
	background-image: -gtk-gradient (linear,
                                 	center top, center bottom,
                                 	color-stop(0.5,green),
                                 	color-stop(0.5,blue),   
	}
#+END_SRC
[[./img/img_2015_03_24__11_29_23.png]]
*** CSS Attributes/ Gtk Supported Properties  #(background-color)
**** Standard Attributes/Properties
Not all properties supported. Some may be added later.

Some currently supported:
#+BEGIN_SRC css
background-color : [color|transparent]
background-image : [none|url|linear-gradient], ..  /*
- borders drawn on top of image.
- background-color drawn beneath.
https://developer.gnome.org/gtk3/stable/GtkCssProvider.html#id-1.5.3.10.11.41
*/
background-repeat: [repeat|no-repeat|space|round|repeat-x|repeat-y];

color : [color|transparent]
border-color : [C|T]{1,4} /* see ref */
border-[top|right|..]-color : ... 
font-family : name;
font-style : [normal|oblique|italic]
font-variant : [normal|small-caps]  /*  uses same font, but smaller size */
font-weight: [normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900];
  /* normal = 400, bold=700 */
font-size: [absolute-size|relative-size|percentage]; /* see ref */
font-*.... /* See ref */

margin : ...
margin-[top|left|...]-* : ...
padding : 
padding-[top|left|...]-* : ...

#+END_SRC

See : Supported Properties: (Link may change in future)
https://developer.gnome.org/gtk3/stable/GtkCssProvider.html#id-1.5.3.10.11  

**** Widget Specific properties
Unique to each widget (e.g GtkComboBox, GtkButton).  
Name of widget preceeds property name.
E.g to use 'indicator-size' property, you would:

~-GtkCheckButton-indicator-size: value~
*** Image support
.gif   .jpeg   .png   .svg 
" background-image: url('/home/me/Pictures/GtkCube.svg');\n"
*** Compatability note (background-image vs background)
On ubuntu, for GtkButton, background-image doesn't work properly.
Best use 'background' consitently. 
Source: [[http://speritzl9001.github.io/MoonLightCoffee/#Compatibility%20Notes][Compatability notes]]

*** General examples 
- Set Background for all controls.[[https://thegnomejournal.wordpress.com/2011/03/15/styling-gtk-with-css/][src]] ::
#+BEGIN_SRC css

/* background-color */
 * {
      background-color: orange;
}

/* background-image gradient: */
*{
      background-image: -gtk-gradient (linear,
                                       left top,
       left bottom,
       from (#d0e4f7),
       color-stop (0.5, darker (#d0e4f7)),
       to (#fdffff));
}
#+END_SRC
*** Example CSS sheets 
Adwaita-clean-dark CSS definition.
https://gitorious.org/gtk-theme/adwaita-clean-dark/source/70fc6ef31ade129567b72bd45e05007d10605400:gtk-3.0/gtk-widgets.css~#L163
*** References
https://developer.gnome.org/gtk3/stable/GtkCssProvider.html
** GtkStyleProvider
:PROPERTIES:
:ID:       6506d617-1c09-44a4-8a86-b7492ee63d1f
:END:
*** About
Interface to provide style information to GtkStyleContext

gtk_style_provider_get_style_property() -- get a value for a style property of a widget.
** GtkStyleProperties (Deprecated as of 3.16)
:PROPERTIES:
:ID:       e2bba5e6-ab3a-42d6-99cf-3b708b9949b5
:END:
** GtkWidgetPath
:PROPERTIES:
:ID:       baebfb6b-4833-4fc0-a14d-7f2b454c2b5d
:END:
*** About
Hierarchy from typically toplevel widget to any child.

Used by GtkStyleContext.

- Direct usage note ::
  Note, if using Gtk+ directrly, probably don't need this. There is 
  ~gtk_widget_get_path()~ that get's the path of a widget.
  And styleContext returned by  ~gtk_widget_get_style_context()~
  will be automatically updated on widget hierarchy changes.


*** References
https://developer.gnome.org/gtk3/stable/gtk3-GtkWidgetPath.html
** GtkIconTheme 
:PROPERTIES:
:ID:       06185a54-631f-4670-bbf1-be56832a12ad
:END:
*** About
Look up icons by name.

*** References
https://developer.gnome.org/gtk3/stable/GtkIconTheme.html
** Examples (Gtk Code)
[[id:95ab39d1-b061-4878-9670-689ed2bfdb5d][CSS Provider (blue Background)]]
** References
Gtk3 Class overview:
[[https://developer.gnome.org/gtk3/stable/theming.html][Theming www]].  
- [[id:b4367994-ad0a-4f66-8c88-95928c99808c][GtkStyleContext]] ([[https://developer.gnome.org/gtk3/stable/GtkStyleContext.html][www]])- Render Ui Elements.  
- [[id:6506d617-1c09-44a4-8a86-b7492ee63d1f][GtkStyleProvider]]  ([[https://developer.gnome.org/gtk3/stable/GtkStyleProvider.html][www]]) - Interface to provide style information to GtkStyleContext.  
- [[id:e2bba5e6-ab3a-42d6-99cf-3b708b9949b5][GtkStyleProperties]] ([[https://developer.gnome.org/gtk3/stable/gtk3-GtkStyleProperties.html][www]]) - A 'Store' for style property information.  
- [[id:0b505e4f-e64c-4d7d-9997-fbb9b1cfc057][GtkCssProvider]] ([[https://developer.gnome.org/gtk3/stable/GtkCssProvider.html][www]]) - CSS like styling for widgets.  
                   Understands 'CSS'.  
- [[id:baebfb6b-4833-4fc0-a14d-7f2b454c2b5d][GtkWidgetPath]] ([[https://developer.gnome.org/gtk3/stable/gtk3-GtkWidgetPath.html][www)]] - Widget path abstraction.  
- [[id:06185a54-631f-4670-bbf1-be56832a12ad][GtkIconTheme]] ([[https://developer.gnome.org/gtk3/stable/GtkIconTheme.html][www]]) - Looking up icons by name.  


Pdf Lecture slides:  
https://desktopsummit.org/sites/www.desktopsummit.org/files/Theming%20GTK3%20Widgets%20with%20CSS.pdf
CSS Tutorials:  
http://speritzl9001.github.io/MoonLightCoffee/

Overview article:
http://www.gtkforums.com/viewtopic.php?f=3&t=988&p=72088=GTK3+with+CSS#p72088

Blogs:
 - 'CSS' parts of gtk styling
 https://thegnomejournal.wordpress.com/2011/03/15/styling-gtk-with-css/
 - 'CSS' parts of gtk styling 2. 
 https://blogs.gnome.org/carlosg/2010/08/23/css-like-styling-for-gtk/
 
* Icons
** About 
Useful:
 [[https://docs.google.com/spreadsheet/pub?key%3D0AsPAM3pPwxagdGF4THNMMUpjUW5xMXZfdUNzMXhEa2c&output%3Dhtml][> Mapping Stock to icon name]] 
 [[http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html][> General icon naming specification]] 
 [[https://docs.google.com/document/d/1KCVPoYQBqMbDP11tHPpjW6uaEHrvLUmcDPqKAppCY8o/pub][> Stock deprecated, migration to named disscussion]]

Meh:
 [[https://developer.gnome.org/gtk3/stable/checklist-named-icons.html][> Gtk2 to Gtk3 note about using named icons]]
 [[http://gtk.10911.n7.nabble.com/Stock-Items-Deprecation-td81617i20.html][> forum disscussion on stock icon deprecation]]
 [[http://askubuntu.com/questions/46761/how-do-i-get-the-names-in-my-icon-theme-for-use-with-pythons-appindicator-module][> S.O list available names (but in python code)]]
** Gtk utility for browsing icons 
gtk3-icon-browser  
This utility shows a preview of all icons in the current theme.
[[./img_gtk.org/img_2015_02_10__17_03_32.png]]

** Stock Items (GTK2) (Deprecated)
*** Stock icons
Stock items are getting deprecated as of ~3.10 and some before.

OS.java seems to defined some:
 GTK_STOCK_FIND = ascii("gtk-find");
 GTK_STOCK_CANCEL = ascii("gtk-cancel");
 GTK_STOCK_CLEAR = ascii("gtk-clear");

 [[https://developer.gnome.org/gtk3/stable/gtk3-Stock-Items.html#GTK-STOCK-ABOUT:CAPS][gtk stock item ref]]

*** Stock icon depreciation
 - No longer needed as GNOME Icon Theme can do all.

** Named icons (GTk3 only thou)
[[https://docs.google.com/spreadsheet/pub?key%3D0AsPAM3pPwxagdGF4THNMMUpjUW5xMXZfdUNzMXhEa2c&output%3Dhtml][Mapping between stock to named icons]]
[[https://docs.google.com/document/d/1KCVPoYQBqMbDP11tHPpjW6uaEHrvLUmcDPqKAppCY8o/pub][discussion on migration from stock to named icons]]
[[https://developer.gnome.org/icon-naming-spec/][gnome icon spec]]

NOTE: use these only in gtk3. In gtk2 there is no guarantee that themed icons are available.

For example usage, see SWT:Text:create handle uses setting entry icon from name.

Gtk functions 
  - [[https://developer.gnome.org/gtk3/stable/GtkWindow.html#gtk-window-set-icon-name][gtk_window_set_icon_name()]]
  - gtk_drag_source_set_icon_name ()
  - [[https://developer.gnome.org/gtk3/stable/GtkImage.html#gtk-image-set-from-icon-name][gtk_image_set_from_icon_name ()]]  << GtkImage

e.g set_icon_name call:
=gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), “document-save”);=
  see Toolbar Items in [[https://docs.google.com/document/d/1KCVPoYQBqMbDP11tHPpjW6uaEHrvLUmcDPqKAppCY8o/pub][migration guide]]

e.g 2
=gtk_window_set_icon_name (GTK_WINDOW (main_window), "text-
* Menus, MenuBars and MenuItems [[elisp:(my/list-parents )][parents]] 
:PROPERTIES:
:ID:       785bfc85-eb29-4902-b0eb-03190b7b4037
:END:
** About/links 

Menu Bar Tutorial: http://zetcode.com/tutorials/gtktutorial/menusandtoolbars/
Lecture notes on menus: http://compsci.hunter.cuny.edu/~sweiss/course_materials/csci493.70/lecture_notes/GTK_menus.pdf

** Theory 
*** Only menu items can be added to menu's.
Menu Items are the only valid children for menus: 
=menu items are only valid children for menus= [[http://zetcode.com/tutorials/gtktutorial/menusandtoolbars/][ZetCode tutorial]]

I tried some code that would add a label, but got an error:
(gtk3_testing:30179): Gtk-CRITICAL **: gtk_menu_shell_insert: assertion 'GTK_IS_MENU_ITEM (child)' failed

** Basic usage 
- Declare things ::
  GtkWidget *menubar;
  GtkWidget *filemenu;
  GtkWidget *file;
  GtkWidget *quit;

- Init menus ::
  menubar = gtk_menu_bar_new();
  filemenu = gtk_menu_new();

- Init Menu Items ::
  file = gtk_menu_item_new_with_label("File");
  quit = gtk_menu_item_new_with_label("Quit");

- Set and append menus ::
  //Set a menubar and it's item:
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(file), filemenu);

  //Append menu items:
  gtk_menu_shell_append(GTK_MENU_SHELL(filemenu), quit);
  gtk_menu_shell_append(GTK_MENU_SHELL(menubar), file);

  gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, FALSE, 3);
** Image menu                                                   :DEPRECATED:
Deprecation commit:
https://git.gnome.org/browse/gtk+/commit/?id=627a03683f5f41efbfc86cc0f10e1b7c11e9bb25

Note that you might have Gnome configured not to show menu images.
To turn the menu images on, we launch the gconf-editor and go to
/desktop/gnome/interface/menus_have_icons 
and check the option.
** Examples 
[[id:d5b7f44a-4cc9-468b-9e81-74ff7232bbf9][Basic Gtk menu with File->quit]]
* GDK
** GdkWindow 
*** Introduction 
- Wrapper :: .
  Wrapper around Xlib's Window object

- Build ing block :: .
  basic building block, GtkWidgets made out of these.
  draw graphics onto a gdk window.

- Some Operations require GdkWindows :: . 
  Some operations like events need a GdkWindow. 

- Shown/Hidden == mapping/unmapping :: 

- You can __ with it :: 
  - capture events 
  - draw graphics
  - move/resize it.
*** "No Window widgets" .
  - Most widgets have a GdkWindow, with some exceptions 
    e.g GtkLabel, these are refered to as  "No Window Widgets".
  - These are usually lightweight.
    These draw into parent's GdkWindow.
  - They are flagged with "GTK_NO_WINDOW", can be tested with:
    GTK_WIDGET_NO_WINDOW() macro.
  - They don't receive events. You can use GdkEventBox to capture events.
*** General Use case 
Genrally used in widget implementation 
- gdk_window_new() to make 
- gdk_window_destory() to destroy.
*** _GdkWindow struct 
/gdkinternals.h/

#+BEGIN_SRC c
struct _GdkWindow
{
  GObject parent_instance;
  //..

  gpointer user_data; // Pointer to some generic data. Usually this is the GtkWidget.
  //
}
#+END_SRC

*** GdkWindow attributes
:PROPERTIES:
:ID:       0f8d85b0-edee-4a11-bdb9-2f9ea0a74103
:END:
gdk_window_new() asks for: 
 - ~GdkWindowAttr~ object. (X/Y etc...).
   Some attributes are optional. Fields w/o attribute flags are required.
 - ~gint attribute_mask~ mask, to indicate which optional fields are used.

#+BEGIN_SRC c
.. gdkwindow.h
struct _GdkWindowAttr
{
  gchar *title;
  gint event_mask;
  gint x, y;
  gint width;
  gint height;
  GdkWindowWindowClass wclass;
  GdkVisual *visual;
  GdkWindowType window_type;
  GdkCursor *cursor;
  gchar *wmclass_name;
  gchar *wmclass_class;
  gboolean override_redirect;
  GdkWindowTypeHint type_hint;
};
#+END_SRC

- title ::
    Used by window managers. Don't have to specify, let usesrs set it via gtk_window_set_title(). 
- event_mask :: 
    Which events will be received by this window.
- X & Y coords :: 
  - Pixel specific.
  - relative to parent. Based on top-left corner.
- GdkWindowClass ::
  - GDK_INPUT_OUTPUT :: Standard, display stuff. 
  - GDK_INPUT_ONLY :: Used as invisible layer to caputre events / change cursors etc..
- Visual :: which colors can be used.
- GdkWindowType ::
  - GDK_WINDOW_ROOT :: has no parent. Covers entire screen, created by window system.
  - GDK_WINDOW_TOPLEVEL :: e.g GtkWindow uses this. 
  - GDK_WINDOW_CHILD :: e.g GtkEntry uses this.

*** GtkWindow vs GdkWindow
 - GtkWindows is what users normally see as windows. (X - buttons). 
 - GtkWidgets are made up of one or many GdkWindows.
*** References
https://developer.gnome.org/gdk3/unstable/gdk3-Windows.html#GdkWindow
*** Functions
: void gdk_window_lower (GdkWindow *window);  //#Underneath #Below
** States
:PROPERTIES:
:ID:       d37af15c-1496-4cba-9228-5404e43fbc3c
:END:
*** Relation Diagram 
#+BEGIN_SRC dot :file ./img/img_2015_05_06__11_43_44.png :cmdline -Kdot -Tpng
digraph { 
  Unallocated -> Realized [label="gtk_widget_realize()"]
  Realized -> Mapped [label="gdk_window_show()"]
  Mapped -> Visible [label="gtk_widget_show()"]
}
#+END_SRC

#+results:
[[file:./img/img_2015_05_06__11_43_44.png]]

*** - Realized
Widget realized when GdkWindow is created.
: gtk_widget_realize()
: gtk_widget_unrealize()

- It also realizes the parents. 
- Destroying a widget destroys things recusivley.
*** - Mapped
Widget is *mapped* if ~gdk_window_show()~ has been called on GdkWindow. 
I.e, server asked to display window on screen. Realize must have happened.
*** - Visible
- Visible :: .
  - Widget is visible if it will be *automatically* mapped, when it's *parent* is mapped.
  - ~gtk_widget_show()~ has been called on the widget.

- Invisible :: .
  Can be made via: ~gtk_widget_hide()~. This will schedule an unmap of the gdkwindow.

Top level windows have no parents, so they are mapped as soon as they are shown.
*** Showing widgets
- In genreal, showing the widget implies realizing and mapping it.
- Show schedules the show event. I.e widgets can be shown out of order.
  -> you can't access GdkWidget of a window immediatley. 
  -> If you want to access, need to call ~gdk_widget_realize()~ manually. (but this is uncommon).
*** References 
Book [fn:1]
** GDK Events 
:PROPERTIES:
:CREATED:  <2015-05-07 Thu 14:09>
:ID:       0188e9a9-01f4-4853-a798-2d6e74d61030
:END:
*** Header files of relevance
- gdkevents.h ::
     events
- gdktypes.h ::
     masks
- gdkwindow.h ::
     adding/setting events on Gdk level.
- gtkwidget.h ::
     adding/setting events on Gtk level.
*** About gdkevents.h
All events are assosiated with a GdkWindow.
Also come to be assosiated with a GtkWidget. 

Gtk+ main loop passes events from GDK to the GTK+ widget tree. 

- GdkEvent :: /gdkevents.h/
     A uninion of these can represent any event.

     #+BEGIN_SRC c
     union _GdkEvent
     {
       GdkEventType		    type;
       GdkEventAny		    any; 
       GdkEventExpose	    expose;
       GdkEventVisibility	    visibility;
       GdkEventMotion	    motion;
       GdkEventButton	    button;
       GdkEventTouch             touch;
       GdkEventScroll            scroll;
       GdkEventKey		    key;
       GdkEventCrossing	    crossing;
       GdkEventFocus		    focus_change;
       GdkEventConfigure	    configure;
       GdkEventProperty	    property;
       GdkEventSelection	    selection;
       GdkEventOwnerChange  	    owner_change;
       GdkEventProximity	    proximity;
       GdkEventDND               dnd;
       GdkEventWindowState       window_state;
       GdkEventSetting           setting;
       GdkEventGrabBroken        grab_broken;
     };
     #+END_SRC

*** GdkEventAny struct
any event can be cast to this. Contains 3 fields common to all.
 #+BEGIN_SRC c
 struct _GdkEventAny
 {
   GdkEventType type; //Common with GdkEvent.
   GdkWindow *window;
   gint8 send_event;
 };
 #+END_SRC
 Thus type can be refered to in many ways:
 : event->type
 : event->any.type
 : event->button.type
 : ((GdkEventAny)*)event)->type
 : ((GdkEventButton*)event)->type
*** GdkEventType enum
Multiple events map to a single GdkEvent Member. 

e.g 
- GdkEventAny  :: GDK_DELETE, GDK_DESTROY
- GdkEventButton :: GDK_BUTTON_PRESS, GDK_2BUTTON_PRESS, GDK_BUTTON_RELEASE
etc.. See structures of  gdkevents.h  like _GdkEventButton
*** Event Masks (gdktypes.h)
- Each GdkWindow has an assisiated /event mask/. 
  This determines which events are forwarded to your application.
- Specified when GdkWindow is created. See [[id:0f8d85b0-edee-4a11-bdb9-2f9ea0a74103][GdkWindow attributes]]
- Can be modified later via:
  : gdk_window_set_events()
  : gdk_window_get_events()

- If GdkWindow belongs to a widget, use the *gTk* versions instead :
  : gtk_widget_set_events() //after widget realization
  : gtk_widget_add_events() //use at any time.

- Method signatures ::
  : gint gdk_widget_get_events (GtkWidget* widget);
  : void gtk_widget_add_events (GtkWidget* widget, gint event_mask);
  : void gtk_widget_set_events (GtkWidget* widget, gint event_mask);

- event_masks :: /gdktypes.h/
    There is a mapping between Event Type and it's Event Mask.
   
    Usually a "_MASK" is appended to the event.
    GDK_KEY_PRESS (event) -> GDK_KEY_PRESS_MASK

    So:
    MASKS live in : *gdktypes.h*
    EVENTS live in: *gdkevents.h*

    #+BEGIN_SRC c
    typedef enum
    {
    GDK_EXPOSURE_MASK             = 1 << 1,
    GDK_POINTER_MOTION_MASK       = 1 << 2,
    GDK_POINTER_MOTION_HINT_MASK  = 1 << n3,
    //    ...
    GDK_SMOOTH_SCROLL_MASK        = 1 << 23,
    GDK_ALL_EVENTS_MASK           = 0xFFFFFE
    } GdkEventMask;
    #+END_SRC
*** Receiving GDK Events in GTK+                                  :DIAGRAM:
In a GTK+ program, you will never receive GDK events directly. 

GDK events are fed into GtkWidget, which emits a corresponding signal.
#+BEGIN_SRC dot :file ./img/img_2015_05_08__14_29_10.png :cmdline -Kdot -Tpng
digraph { 
  XEvent -> GDK_EVENTS [label=" low lvl signal"]; 
  GDK_EVENTS -> GtkWidget [label=" Gdk Signals\nadded to queue"]
  GtkWidget -> GTK_EVENTS [label=" Gtk+ Signals\nget processed"]
  you [style=filled fillcolor=gold2]
  you -> GtkWidget [label="Connect signals"] 
  GTK_EVENTS -> GTK_EVENTS [label=" FALSE==Propogate"]
  end [style=filled fillcolor=red]
  GTK_EVENTS -> end [label=" TRUE==STOP"]
}
#+END_SRC

#+results:
[[file:./img/img_2015_05_08__14_29_10.png]]

Note, some events are special, e.g DnD.
*** Relation diagram                                              :DIAGRAM:
#+BEGIN_SRC dot :file ./img/img_2015_05_11__11_41_28.png :cmdline -Kdot -Tpng
digraph  {
 node [shape=record]
 rankdir="BT"
 GdkModifierType [label="{GdkModifierType|(Masks for shift/ctrl)}"]
 GdkEventButton -> GdkModifierType
 GdkEventKey -> GdkModifierType
 GdkEventMotion -> GdkModifierType
 GdkEventCrossing -> GdkModifierType
}
#+END_SRC

#+results:
[[file:./img/img_2015_05_11__11_41_28.png]]

*** Grabs & progagation 
[[./img/img_2015_05_08__16_59_14.png]]
[[./img/img_2015_05_08__16_59_06.png]]
[[./img/img_2015_05_08__16_59_22.png]]
*** Return values of events 
- If event handler returns TRUE, event handling stops.
- FALSE, propogates to parent.
- Default is FALSE. 

Mnemonic: Did I handle the signal?
*** Button events (GdkEventButton struct)
- GDK_BUTTON_PRESS etc.
- See: _GdkEventButton struct.

GdkEventButton 
 x_root & y_root are relative to root window, not to local window. Like absolute coords for window.
*** Modifier Masks 
Useful to check if some modifier (shift) was pressed during a button press.

- Prefer to check presence rather than exact value.
  i.e, good:  
  : if ( (state & GDK_SHIFT_MASK) == GDK_SHIFT_MASK )
  Not good: 
  : if ( state == GDK_SHIFT_MASK )  //Fails on things like num-lock being turned on.

e.g.. 
- <gdktypes.h> ::
  GDK_SHIFT_MASK
  GDK_LOCK_MASK
  GDK_CONTROL_MASK etc.. 
  GDK_BUTTON1_MASK etc.. 
*** Keyboard events (GdkEventKey struct)
- 2 events ::
  GDK_KEY_PRESS
  GDK_KEY_RELEASE

- Not all hardware sends keyboard events 

#+BEGIN_SRC c
struct _GdkEventKey
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  guint32 time; // key specific.
  guint state;  // GdkModifierType Modifier keys. 
  guint keyval; //key syms -> gdkkeysyms.h e.g GDK_KEY_M
  gint length;
  gchar *string;  //Read this as application.
  guint16 hardware_keycode;
  guint8 group;
  guint is_modifier : 1;
};
#+END_SRC

- keyval ::
  - physical to virtual mapping.
  - Users can re-arrange, e.g to generate the DVORAK keybaord.

- useful ::
  gdk_keyval_name()  returns "Home" from "GDK_HOME" 
  gdk_keyval_is_lower() :: returns FALSE if it has upper case equivalent 
  ...

For example, see book [fn:1] pg 182.
*** Mouse movement events (GdkEventMotion, GdkEventCrossing structs)
- Motion Events ::
     Movement inside the window.
     GDK_MOTION_NOTIFY
- Crossing Events ::
     Moves between windows.
     GDK_ENTER_NOTIFY
     GDK_LEAVE_NOTIFY

- Tracking ::
  - GDK_POINTER_MOTION_MASK ::
       in event mask of window.
       You will get many of these, handle quickly or get laggy app.
  - GDK_POINTER_MOTION_HINT_MASK :: *Deprecated*
       if it is *also* added, event sent one at a time
  - GDK_BUTTON_MOTION_MASK ::
       Receive motion events when a button is pressed.
       Receive events only for button 1,2,3:
       GDK_BUTTON1_MOTION_MASK, .. 2. 3
      
- Crossing note ::  (pg 185 of [fn:1])
     If it event perculated up from a child window, then the *subwindow is defined. Otherwise it is NULL.
     #+BEGIN_SRC c
       struct _GdkEventCrossing {
         GdkEventType type;
         //..
         GdkWindow *subwindow; /// << 
         gboolean *focus;
         //..
       };
     #+END_SRC

- focus flag :: TRUE if toplevel GtkWindow containing the event window currently has the X Focus.
     
-  Keyboard focus Gdk note ::
  Gdk uses X focus mechanism for windows.
  But Gtk+ has it's own mechanism. Gtk receives all Gdk focus events, but forwards them to widgets.
*** Focus change events (GdkEventFocus struct)
- GDK_FOCUS_CHANGE ::
     - Upon gain/loose of focus.
     - only top level GtkWindows receive/lose focus. They pass to inner widget.

- 'in' field ::
     true if focus in, flase if focus out.
*** Expose event (GdkEventExpose struct)
When previously obscured region of a window becomes visible.

Sent when window first drawn. (i.e don't draw till you get exposure event).

GTK+ usese these for windowless widgets. This is the only event GTK_NO_WINDOW 
widgets will receive.

~gdk_window_copy_area()~ can trigger expose events also. Exposure events triggered for
destination window. Can be turned off by calling ~gdk_gc_set_exposures()~ on the graphics context
passed to ~gdk_gc_set_exposures()~
p
#+BEGIN_SRC c
struct _GdkEventExpose
{
  GdkEventType type;
  GdkWindow *window;
  gint8 send_event;
  GdkRectangle area;
  cairo_region_t *region;
  gint count; /* If non-zero, how many more events follow. for optimizing drawign */
};
#+END_SRC
*** Window Change Events 
As a GdkWindow is shown/hidden/resized or destroyed, evetns are emitted.

- GdkEventConfigure ::
     size or position has changed. 

Useful:
 - When window resized by window manager. Make
 - GtkDrawingArea sends it to self upon resize. Useful for repainting.
   send_event will be TRUE for such cases.

Other changes in GdkWindow signalled with GdkEventAny, distinguished by type field:
- GDK_DELETE :: destroy window.  Can make return TRUE to stop destruction of window.
- GDK_DESTROY :: 
- GDK_MAP :: shown on screen. But you should wait till exposure event.
- GDK_UNMAP :: hidden, iconified, or gdk_widget_hide() was called upon it.
*** Little events
**** Visibility Events (GdkEventVisibility struct)
When obscured or unobscured.
Not as useful, because e.g expose does this already.
**** Property events 
when key-value pair changes.
gtk provides higher level features for this.
**** Selection events 
cut & paste mechanism, useful for GtkText and GtkEntry. 
For when selection changes.

Most widgets use gtk/gtkselection.h thou.
**** Client events 
Data chunks sent between applications.
ICCCM (Inter client communication Conversions manual). 

e.g window manager can send a deletion request.(but Gdk converts to GDK_DELETE) 
Dnd events, but GDK translates to GdkEventDND. 

Usually for unconventional messages that Gdk is not preperd for.
**** (DND) Drag and Drop events
GdkEventDND ...
**** Proximity event 
e.g for tablets, stylus near surface.
** Mouse Pointer
*** Getting pointer location
- Get location via ~gdk_window_get_pointer()~ .
  Coords relative to window passed as first argument.
  : GdkWindow* gdk_window_get_pointer (GdkWindow* window, gint* x, gint* y, Gd-
  :                                    kModifierMask* state);
 if null is passed to X|Y, that coord is ignored.
*** Grabbing the pointer
Events can go to the /grab window/.

E.g when click & drag, change the selection accordinly.

~gdk_pointer_grab()~ to grab the pointer.  (gdkwindow.h) 
Args
 - 1st :: window which will receive grab events, 
 - 2nd :: TRUE|FALSE, go only to grab window or also to child.
 - 3rd :: restrict movement to this window. Note, it is safe to destroy cursor right away.
 - 4th :: when it should take effect, server time.
      Usually used to resovle conflict between two clients.E.g use GDK_CURRENT_TIME macro.

: gint gdk_pointer_grab (GdkWindow* window, gint owner_events, GdkWindow* con-
:                         fine_to, GdkCursor* cursor, guint32 time);
Returns true if succeeds. Fails if window is hidden or invalid args.

: gint gdk_pointer_is_grabbed (void);
: void gdk_pointer_ungrab (guint32 time);
 (stop holding pointer, usually check first).

- GDK vs GKT+ :: 
  - GTK+ grab re-directs events to grabbing widget.(e.g modal widget). 
    GTK+ affects only current application, only events for one widget. 
  - GDK's scope is wider, all of X server.
*** Changing the cursor 
Change via: ~gdk_window_set_cursor()~, on window by window basis.
Restory by setting it to null. 

More in book [fn:1]
** Fonts
<to be filled, read book>
** Graphics Contexts (GC) 
- server side resource.
- Created via GdkGCValues struct. 
- has attributes like GdkWindow.
- gdk_gc_new() 
- visual and depth should match what you're drawing to.(taken from GdkWindow's args). 
  I.e, create GC with window you intend to use with.
** GdkPixmap 
- Client-side handle for object on the X Server
- pixel to-pixel ops are not effective.
- copy pixmap onto window is ok thou, as they are on the same machine.
** Resource Management
- Usually ref/unref makes sure objects are deleted. 
- Some things like cursors & images need to be cleaned up manually.

- GdkWindow is strange case. It is reference counted, but ~gdk_window_destory()~ 
  must be called at some point.
  It's safe to call functions on a destroyed window. They will return immediatley. 
* *Raw notes*
** Object and Type system 
*** Overview (detail) 
Implement the GtkWidget interface.
Usually copy & paste from a similar basic stock widget.
**** Kinds of widgets
- Containers ::
  - Two types ::
    - single child (gtkbutton)
    - multi child with layout (gtkbox, gtktable)
  - Must implement 'Container' interface. (
  - Harder
- Composite ::
  - contain multiple widgets already, nicley packed. (e.g GtkFileSelection).
  - Easier 
- Non container ::
     - actual controls, e.g buttons, scrollbars, info displays (labels).
**** What a widget does
- Creation and destruction ::
     initializers, shutdown, destroy and finalize methods
- Map/Unmap/unrealisze ::
- Gemoetry negotiation :: 
- Drawing :: 
- Unique functionality :: 
     Widget's custom functions.
*** Navigating objects in Gtk
Open the *.h file of a widget, look for the object struct
that has a '_' prefix. E.g _GtkButton, _GtkWidget.

- object struct :: /parent & data link/
  - *.h files contain the object struct e.g _GObject, _GtkWidget.
  - This is the struct that defines a widget.
  - links to parent.
  - links to private Data struct 

Inside the *.h file, also seek the class struct, it lists signal handling pointers. 

- Class struct :: /Instance Function pointers/
  *.h files contain the class struct, e.g _GObjectClass, _GtkWidgetClass

Lastly, open the *.c file and inspect the private data struct, to see what data the widget has:

- private Data struct :: /Instance Data/
  - *.c files contain the private data of the widget in it's *Private (aka priv) struct.

Example:
#+BEGIN_SRC c
struct _GtkButton
{
  /*< private >*/
  GtkBin bin;    // <<< Pointer to parent.
  GtkButtonPrivate *priv; //< pointer to instance data struct.
};

struct _GtkButtonClass
{
  GtkBinClass        parent_class;  //<< Pointer to parent class.

  /*< public >*/
  void (* pressed)  (GtkButton *button); //Signals that are handled.
  void (* released) (GtkButton *button);
 ...
};

#+END_SRC
*** Checking type
Each object usually provides a function to return it's type.
: GType          gtk_button_get_type          (void) G_GNUC_CONST;
This is an int.

There are macros for casting. Functions can use those to test type:
: g_return_if_fail(GTK_IS_BUTTON(widget));
*** Finalization 
- Chained : shutdown -> destroy -> finalize 
- if you override, need to manually chain further. 

shutdown : run stuff before destruction. Not usually overriden. 
destroy : marks "usless", cleans up resuoruces. Does not free up object. (usually overriden)
finalize: when object's ref count reaches 0.
*** Widget implementation (extending)
**** Realization and Mapping
- When to override ::
  Any widget with a GdkWindow that has a GtkWidget as parent will need to override the realize method.
  Only windowless widgets's don't need to override.
- Assign window to widget ::
  via 
  : gtk_widget_set_window (widget, window);
  : gdk_window_set_user_data (window, widget);

** Wrtiting a GtkWidget 
*** GtkWidget Base Class 
**** Overridable Signals

*** References 
Red hat book: [fn:1] 
Gtk Book: [fn:2]
* Examples and code snippets                                        :EXAMPLE:
** Reparenting of a button in a tabfolder                           :EXAMPLE:
#+BEGIN_SRC c++
#include <gtk/gtk.h>

static void destroy (GtkWidget*, gpointer);

GtkWidget *window, *notebook;
GtkWidget *label1, *label2, *tabContainer1, *tabContainer2, *child1, *child2, *child3;

int pg;

void tab_page_swtiched_handler (GtkNotebook *notebook,
               GtkWidget   *page,
               guint        page_num,
               gpointer     user_data) {

	g_message("tab switched");

	if (pg == 0) {
		pg = 1;
		return;
	}

	if (pg == 1) {
		pg = 2;
		gtk_widget_reparent(child1, tabContainer2);
	} else if (pg == 2) {
		pg = 1;
		gtk_widget_reparent(child1, tabContainer1);
	}
}

int main (int argc,
          char *argv[])
{

  pg = 0;

  gtk_init (&argc, &argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title (GTK_WINDOW (window), "Notebook");
  gtk_container_set_border_width (GTK_CONTAINER (window), 10);
  gtk_widget_set_size_request (window, 250, 100);

  g_signal_connect (G_OBJECT (window), "destroy",
                    G_CALLBACK (destroy), NULL);

  notebook = gtk_notebook_new ();
  label1 = gtk_label_new ("Page One");
  label2 = gtk_label_new ("Page Two");


  tabContainer1 = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
  tabContainer2 = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);


  child1 = gtk_button_new_with_label ("Dynamic button");
  child2 = gtk_button_new_with_label ("page 1 button 2");
  child3 = gtk_button_new_with_label ("page 2 button");

  //Error message upon adding 2nd child.
  //  (gtk3_testing:17322): Gtk-WARNING **: Can't set a parent on widget which has a parent


  gtk_box_pack_start(GTK_BOX(tabContainer1), child1, TRUE, TRUE, 1);
  gtk_box_pack_start(GTK_BOX(tabContainer1), child2, TRUE, TRUE, 1);
  gtk_box_pack_start(GTK_BOX(tabContainer2), child3 , TRUE, TRUE, 1);

  /* Append to pages to the notebook container. */

  gtk_notebook_append_page (GTK_NOTEBOOK (notebook), tabContainer1, label1); //<LREF__0000141
  gtk_notebook_append_page (GTK_NOTEBOOK (notebook), tabContainer2, label2);

  gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook), GTK_POS_TOP);  //<LREF__0000142

  gtk_notebook_set_scrollable (GTK_NOTEBOOK (notebook), TRUE);  //<LREF__0000143

  g_signal_connect( GTK_NOTEBOOK(notebook), "switch-page", G_CALLBACK( tab_page_swtiched_handler ), NULL );

  gtk_container_add (GTK_CONTAINER (window), notebook);
  gtk_widget_show_all (window);

  gtk_main ();
  return 0;
}


static void
destroy (GtkWidget *window,
         gpointer data)
{
  gtk_main_quit ();
}
#+END_SRC
** Basic Gtkenu with File->quit                                :GTK3:EXAMPLE:
:PROPERTIES:
:ID:       d5b7f44a-4cc9-468b-9e81-74ff7232bbf9
:END:
src: http://zetcode.com/tutorials/gtktutorial/menusandtoolbars/
#+BEGIN_SRC c++
#include <gtk/gtk.h>

int main( int argc, char *argv[])
{

  GtkWidget *window;
  GtkWidget *vbox;

  GtkWidget *menubar;
  GtkWidget *filemenu;
  GtkWidget *file;
  GtkWidget *quit;

  gtk_init(&argc, &argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
  gtk_window_set_default_size(GTK_WINDOW(window), 250, 200);
  gtk_window_set_title(GTK_WINDOW(window), "menu");

  vbox = gtk_vbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(window), vbox);

  menubar = gtk_menu_bar_new();
  filemenu = gtk_menu_new();

  file = gtk_menu_item_new_with_label("File");
  quit = gtk_menu_item_new_with_label("Quit");

  gtk_menu_item_set_submenu(GTK_MENU_ITEM(file), filemenu);
  gtk_menu_shell_append(GTK_MENU_SHELL(filemenu), quit);
  gtk_menu_shell_append(GTK_MENU_SHELL(menubar), file);
  gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, FALSE, 3);

  g_signal_connect_swapped(G_OBJECT(window), "destroy",
        G_CALLBACK(gtk_main_quit), NULL);

  g_signal_connect(G_OBJECT(quit), "activate",
        G_CALLBACK(gtk_main_quit), NULL);

  gtk_widget_show_all(window);

  gtk_main();

  return 0;
}
#+END_SRC
** Color Examples
*** GdkColor                                                 :GTK2:EXAMPLE:
:PROPERTIES:
:ID:       8af4a1e7-81ce-41cb-8196-6a3991c2ed30
:END:
Gdk color is deprecated. But here is an example of it's use.
[[./img/img_2015_03_03__15_03_41.png]]

#+BEGIN_SRC c++
#include <gtk/gtk.h>

static void destroy (GtkWidget*, gpointer);
static void color_changed (GtkColorButton*, GtkWidget*);

int main (int argc,
          char *argv[])
{
  GtkWidget *window, *button, *label, *hbox;
  GdkColor color;

  gtk_init (&argc, &argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title (GTK_WINDOW (window), "Color Button");
  gtk_container_set_border_width (GTK_CONTAINER (window), 10);

  g_signal_connect (G_OBJECT (window), "dest
roy",
                    G_CALLBACK (destroy), NULL);

  /* Set the initial color as #003366 and set the dialog title. */
  gdk_color_parse ("#003366", &color);
  button = gtk_color_button_new_with_color (&color);

  //Set a title for the popup.
  gtk_color_button_set_title (GTK_COLOR_BUTTON (button), "Select a Color");

  label = gtk_label_new ("Look at my color!");
  gtk_widget_modify_fg (label, GTK_STATE_NORMAL, &color);  //<LREF__0000199

  g_signal_connect (G_OBJECT (button), "color_set",
                    G_CALLBACK (color_changed),
                    (gpointer) label);

  hbox = gtk_hbox_new (FALSE, 5);
  //Gtk2
  // gtk_box_pack_start_defaults (GTK_BOX (hbox), button);
  // gtk_box_pack_start_defaults (GTK_BOX (hbox), label);
  
  //gtk3
  gtk_box_pack_start (GTK_BOX (hbox), button, TRUE, TRUE, 2);
  gtk_box_pack_start (GTK_BOX (hbox), label, TRUE, TRUE, 2);

  gtk_container_add (GTK_CONTAINER (window), hbox);
  gtk_widget_show_all (window);

  gtk_main ();
  return 0;
}

/* Retrieve the selected color and set it as the GtkLabel's foreground color. */
static void
color_changed (GtkColorButton *button,
               GtkWidget *label)
{
  GdkColor color;
  gtk_color_button_get_color (button, &color);
  gtk_widget_modify_fg (label, GTK_STATE_NORMAL, &color);
}

static void
destroy (GtkWidget *window,
         gpointer data)
{
  gtk_main_quit ();
}
#+END_SRC
*** GdkRGBA                                                  :GTK3:EXAMPLE:
:PROPERTIES:
:ID:       64e4de34-de11-44a7-a326-1d26219f9500
:END:
Similar to GdkColor, but using gtk3's GdkRGBA
#+BEGIN_SRC c++
#include <gtk/gtk.h>

static void destroy (GtkWidget*, gpointer);
static void color_changed (GtkColorButton*, GtkWidget*);

int main (int argc,
          char *argv[])
{
  GtkWidget *window, *button, *label, *hbox;
  GdkColor color;
  GdkRGBA rgbaColor;

  gtk_init (&argc, &argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title (GTK_WINDOW (window), "Color Button");
  gtk_container_set_border_width (GTK_CONTAINER (window), 10);

  g_signal_connect (G_OBJECT (window), "destroy",
                    G_CALLBACK (destroy), NULL);

  /* Set the initial color as #003366 and set the dialog title. */
//  gdk_color_parse ("#003366", &color);
//  button = gtk_color_button_new_with_color (&color);

  gdk_rgba_parse(&rgbaColor, "#003366");
  button = gtk_color_button_new_with_rgba (&rgbaColor);


  //Set a title for the popup.
  gtk_color_button_set_title (GTK_COLOR_BUTTON (button), "Select a Color");

  label = gtk_label_new ("Look at my color!");
  gtk_widget_modify_fg (label, GTK_STATE_NORMAL, &color);  //<LREF__0000199

  g_signal_connect (G_OBJECT (button), "color_set",
                    G_CALLBACK (color_changed),
                    (gpointer) label);

  hbox = gtk_hbox_new (FALSE, 5);
  //Gtk2
  // gtk_box_pack_start_defaults (GTK_BOX (hbox), button);
  // gtk_box_pack_start_defaults (GTK_BOX (hbox), label);

  //gtk3
  gtk_box_pack_start (GTK_BOX (hbox), button, TRUE, TRUE, 2);
  gtk_box_pack_start (GTK_BOX (hbox), label, TRUE, TRUE, 2);

  gtk_container_add (GTK_CONTAINER (window), hbox);
  gtk_widget_show_all (window);

  gtk_main ();
  return 0;
}

/* Retrieve the selected color and set it as the GtkLabel's foreground color. */
static void
color_changed (GtkColorButton *button,
               GtkWidget *label)
{

  GdkRGBA rgbaColor;
  gtk_color_button_get_rgba(button, &rgbaColor);
  gtk_widget_override_color(label, GTK_STATE_FLAG_NORMAL, &rgbaColor);

//  GdkColor color;
//  gtk_color_button_get_color (button, &color);
//  gtk_widget_modify_fg (label, GTK_STATE_NORMAL, &color);
}

static void
destroy (GtkWidget *window,
         gpointer data)
{
  gtk_main_quit ();
}
#+END_SRC
** CSS Provider Styling Window                                         :GTK3:
:PROPERTIES:
:ID:       95ab39d1-b061-4878-9670-689ed2bfdb5d
:END:
[[./img/img_2015_03_24__14_32_46.png]]
#+BEGIN_SRC cpp
#include <gtk/gtk.h>

static void
activate (GtkApplication* app,
          gpointer        user_data)
{
  GtkWidget *window;

  GtkWidget *button;
  GtkWidget *button_box;
  
  window = gtk_application_window_new (app);
  gtk_window_set_title (GTK_WINDOW (window), "Window");
  gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);

  button_box = gtk_button_box_new ( GTK_ORIENTATION_HORIZONTAL );
  gtk_container_add (GTK_CONTAINER (window), button_box);

  button = gtk_button_new_with_label ("Hello World");
  gtk_container_add (GTK_CONTAINER (button_box), button);

/*--- CSS -----------------*/
  GtkCssProvider *provider;
  GdkDisplay *display;
  GdkScreen *screen;

  provider = gtk_css_provider_new ();
  display = gdk_display_get_default ();
  screen = gdk_display_get_default_screen (display);

  gtk_style_context_add_provider_for_screen (screen,
                                 GTK_STYLE_PROVIDER (provider),
                                 GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);

  gtk_css_provider_load_from_data (GTK_CSS_PROVIDER(provider),
                                   " GtkWindow {\n"
                                   "   -GtkWidget-focus-line-width: 0;\n"
                                   "   -GtkWindow-resize-grip-height: 0;\n"    /* not guaranteed, can be overridden by window manger */
                                   "   -GtkWindow-resize-grip-width: 0;\n"     /* not guaranteed, can be overridden by window manger */                       
                                   "   background-color: blue;\n"              /* named color units */
                                   "   background-color: rgb (0, 0, 255);\n"   /* rgb color units, overrides the previous "background-color" assignment */
                                   "   background-color: rgba (0,0,255,1);\n"  /* rgba color units, overrides the previous "background-color" assignment */
                                   "   background-color: #0000FF;\n"           /* hexadecimal color units, overrides the previous "background-color" assignment */
                                   "   background-color: shade(blue, 1.0);\n"  /* overrides previous color assignment */   
                                   "}\n", -1, NULL);
/*-------------------------*/

  gtk_widget_show_all (window);
}

int
main (int    argc,
      char **argv)
{
  GtkApplication *app;
  int status;

  app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
  g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
  status = g_application_run (G_APPLICATION (app), argc, argv);
  g_object_unref (app);  
  return status;
}
#+END_SRC
** CSS Provider styling induvidual widget
 #+BEGIN_SRC C
#include <gtk/gtk.h>

static void
activate (GtkApplication* app,
          gpointer        user_data)
{
  GtkWidget *window;

  GtkWidget *button;
  GtkWidget *button_box;
  
  window = gtk_application_window_new (app);
  gtk_window_set_title (GTK_WINDOW (window), "Window");
  gtk_window_set_default_size (GTK_WINDOW (window), 200, 200);
 
  button_box = gtk_button_box_new ( GTK_ORIENTATION_HORIZONTAL );
  
  gtk_container_add (GTK_CONTAINER (window), button_box);


  button = gtk_label_new("hello gtk"); //Label is styled.

  gtk_container_add (GTK_CONTAINER (button_box), button);

/*--- CSS -----------------*/
  GtkCssProvider *provider;
  GdkDisplay *display;
  GdkScreen *screen;

  provider = gtk_css_provider_new ();
  GtkStyleContext *button_context = gtk_widget_get_style_context(button);
  gtk_style_context_add_provider (button_context, GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_USER);
  gtk_css_provider_load_from_data (GTK_CSS_PROVIDER(provider),
                                   " * {\n"  //NOT SURE ABOUT SELECTOR.
                                   "   background: rgb (255, 0, 0);\n"  //red
				   "   background-color: rgb(255,0,0);\n" //red
                                   "}\n", -1, NULL);
  /*-------------------------*/
  gtk_widget_show_all (window);
}

int
main (int    argc,
      char **argv)
{
  GtkApplication *app;
  int status;

  app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
  g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
  status = g_application_run (G_APPLICATION (app), argc, argv);
  g_object_unref (app);  
  return status;
}
 #+END_SRC
** CSS add class to widget and style from gloabl display
:PROPERTIES:
:ID:       059d5ed7-43d0-40e6-95e7-104b11fd476e
:END:
#+BEGIN_SRC c
#include <gtk/gtk.h>

static void
activate (GtkApplication* app,
          gpointer        user_data)
{
  GtkWidget *window;
  GtkWidget *button;
  GtkWidget *button_box;
  
  window = gtk_application_window_new (app);
  gtk_window_set_title (GTK_WINDOW (window), "Window");
  gtk_window_set_default_size (GTK_WINDOW (window), 200, 200); 
  button_box = gtk_button_box_new ( GTK_ORIENTATION_HORIZONTAL );
  gtk_container_add (GTK_CONTAINER (window), button_box);

  //NOT WORKIGN:
  button = gtk_combo_box_text_new();  //Background not working on this one.

  gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT (button), "hello");
  gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT (button), "World");
  
  gtk_container_add (GTK_CONTAINER (button_box), button);

/*--- CSS -----------------*/
  GtkCssProvider *provider;
  GdkDisplay *display;
  GdkScreen *screen;

  provider = gtk_css_provider_new ();
  display = gdk_display_get_default ();
  screen = gdk_display_get_default_screen (display);

  GtkStyleContext *button_context = gtk_widget_get_style_context(button);
  gtk_style_context_add_class (button_context, "meh");                    ///<<<< Add class
  
  gtk_style_context_add_provider_for_screen (screen,
                                 GTK_STYLE_PROVIDER (provider),
                                 GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);

  gtk_css_provider_load_from_data (GTK_CSS_PROVIDER(provider),
                                   " GtkComboBoxText.meh * {\n"          ///<<< Style globally
                                   "   background: rgb (255, 0, 0);\n"  //red
				   //				   "   background-color: rgb(255,0,0);\n" //red
                                   "}\n", -1, NULL);
  
/*-------------------------*/


  
  gtk_widget_show_all (window);
}

int
main (int    argc,
      char **argv)
{
  GtkApplication *app;
  int status;

  app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
  g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
  status = g_application_run (G_APPLICATION (app), argc, argv);
  g_object_unref (app);  
  return status;
}
#+END_SRC
* References 
Gnome C Platform Demos:
https://developer.gnome.org/gnome-devel-demos/unstable/c.html.en

Gtk2 Tree view tutorial:
http://scentric.net/tutorial/treeview-tutorial.html
* X
X Server - User's workstation.
           Server because it provides services (keyboard/mouse) 
X Client - Actual Machine.

XLib - client for X.
XCB attemp to replace XLib


XLib bits :
 - 
* Wayland
is a protocol.
Frame = set of pixels.
display server = Wayland compositor 

Weston = reference compositor. 


* Footnotes
:PROPERTIES:
:ID:       99b02990-7ca1-46d4-89e1-e11b1b33237c
:END:
[fn:1] GTK+ Gnome Application Development.pdf (Red Hat book) : LR5 
[fn:2] Apress.Foundations.of.GTK.plus.Development.Apr.2007.pdf : LR6 


