#+STARTUP: indent
* Classes 
** Controlling access (Public/Protected/Private keywords)
| Modifier    | Class | Package | Subclass | World |
|-------------+-------+---------+----------+-------|
| Public      | y     | y       | y        | y     |
| Protected   | y     | y       | y        | n     |
| No-modifier | y     | y       | n        | n     |
| Private     | y     | n       | n        | n     |
|-------------+-------+---------+----------+-------|

[[./img/img_2015_03_25__13_56_54.png]]
[[shell:kolourpaint ./img/img_2015_03_25__13_56_54.png][edit img]]
* System Utilities
** System Properties 
System.getProperty([[http://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html][Property_name]])
*** Getting Users Home directory cross-platform way
- CMD :: System.getProperty("user.home")
- E.g out
 :: /home/lufimtse 
* File IO
** Read/Write properties files 
See [[http://www.mkyong.com/java/java-properties-file-examples/][my kong tutorial]]

** Check if file exists 
new File("path/to/file.txt").isFile();
[[http://stackoverflow.com/questions/1816673/how-do-i-check-if-a-file-exists-in-java][src]]
* Data structures 
** Arrays
*** Facts 
- length established at creation;
  - lenght is fixed.
*** Declare 
: int[] anArray;
*** Init 
: anArray = new int[10];  
*** Assign 
: anArray[0] = 100;
*** Shorthand declare & assign 
: int sample[] = {1,2,3,4};
  : new type[] {item1, item2};   //can be used as paramater to a function.
*** Read back 
: anArray[i]
*** Iterarating over array 
: for (int i=0, i < myArray.length; i++) {} 
* @ Collections 

** Swapping two elements 
Collections.swap(list<>, i, j);

* @ Design Patterns
** @ Dependency Injection
*** About 
If a class does not instantiate other classes, it has no hard dependencies. 
[[http://www.vogella.com/tutorials/DependencyInjection/article.html][vogella tutorial]]

*** Example
e.g: No Hard-Dependencies
#+BEGIN_SRC java
package com.example.e4.rcp.todo.parts;
import java.util.logging.Logger;
import org.eclipse.e4.core.services.events.IEventBroker;
public class MyClass {
  
  Logger logger;
  
  public MyClass(Logger logger) {  //Uses class  that was given.
    this.logger = logger;           
    logger.writeInfo("This is a log message.")
  }
} 
#+END_SRC

*** Advantages of Dependency Injection
It's easier to test such classes in isolation. (e.g pass mock objects into it)

*** Java Annotation 
Annotation was introduced in Java Specification Request 330 (JSR330).
@Inject
@Named

e.g 
#+BEGIN_SRC java 
@Inject private Logger logger;  //Injected into field

@Inject  //Injected into paramater of method OR Constructor
public static void Logger(Composite parent) {...}
#+END_SRC
*** Where can you inject things:
- constructor
- field
- paramater of method
- static / non static fields/methods.
 *! avoid injection into statics thou.*
*** Frame works for dependency injection
e.g Google Guice and Spring
Eclipse 4 uses Dependency Injection.

[[/home/lufimtse/Dropbox/Uni/Notes/java.orgIMG/20150127_153133_29137zBW.png]]

[[hello.png]]

* @ GSON (google JASON library)
:LINKS:
Main:
https://code.google.com/p/google-gson/

Tutorials:
http://www.studytrails.com/java/json/java-google-json-introduction.jsp

Basic parsing:
http://www.studytrails.com/java/json/java-google-json-parse-json-to-java.jsp
:END:

** Object to Jason:
GsonBuilder builder = new GsonBuilder();
Gson gson = builder.create();
System.out.println(gson.toJson(YOUR_OBJECT)

** Serialize nulls
builder.serializeNulls();

** Pretty Printing 
builder.setPrettyPrinting().serializeNulls();

** Field name Conversion in files
*** Custom name for fields in file, use annotation
@SerializedName("album_images")
List<AlbumImages> images = new ArrayList<AlbumImages>();

*** Field name translation
Sometimes using annotation is not possible. The other way is to
tell the builder to translate. The following is ran on every field,
to translate java's 'albumId' into 'album_id' in the file.

#+BEGIN_SRC java
builder.setFieldNamingStrategy(new FieldNamingStrategy() {
            @Override
            public String translateName(Field f) {
                if (f.getName().equals("albumId"))
                    return "album_id";
                else
                    return f.getName();
            }
        });
#+END_SRC

** Other customizations include 
 - do not escape html,
 - custom adapters,
 - exclude fields
* @ Bigger Examples 

* @ Threads & Multi-threading
** Thread Sleeping / wait & notify
*** Thread sleep
Thread.sleep(ms)
*** Wait & notify (Thread communication)
**** About
Wait & Notify go together.  
A thread can wait till it get's notified by another thread or by a timeout.

*Note*: Spurious wake ups can occur (system calls). 
        Wait must be inside a while loop that checks a CONDITION.

*Note*: You should enclose wait and notify into synchronized blocks, otherwise 
        you can get a ~IllegalMonitorStateException~ error.
#+BEGIN_SRC java
synchronize (this) {
  while (CHECK-CONDITION) {
   wait(TIMEOUT)
  }
}
//......
synchronize (this)  {
   notify()
}
#+END_SRC
**** Api
WAIT 
 final void wait()                     throws InterruptedException
 final void wait(long mills)           throws InterruptedException
 final void wait(ong mills, int nanos) throws InterruptedException

NOTIFY 
 final void notify()  //wake one 
 final void notifyAll() //wake all. Thread with highest priority will gain access. 
**** Examples
[[id:24e26285-f47b-48b2-893f-8bbbfd8297b9][Tick tock]]
** @ Synchronization
*** @ Volatile variable   #(when it's ok to use them.)
**** Sources
Main article:
http://www.ibm.com/developerworks/java/library/j-jtp06197/index.html

**** About
Under some conditions, it's ok to use volatile variables. 
I.e, variables not enclosed in synchronize() blocks.
**** Two Conditions under which it is ok to use Volatile variables:
1) Writes to the variable do not depend on its current value.
2) The variable does not participate in invariants with other variables.
**** Patterns on when it's safe to use
***** Pattern #1 : Status flag
A one-way transition. E.g one loop checks for shutDown flag continiously.
Then it's ok to alter it. 
#+BEGIN_SRC java
volatile boolean shutdownRequested;

...

public void shutdown() { shutdownRequested = true; }

public void doWork() { 
    while (!shutdownRequested) { 
        // do stuff
    }
}
#+END_SRC
***** Pattern #2 : One-time publication
In essence, the object must either be thread safe or *effectivley immutable* 
(meaning it never really get's modified.).

Example:
#+BEGIN_SRC java
public class BackgroundFloobleLoader {
    public volatile Flooble theFlooble;

    public void initInBackground() {
        // do lots of stuff
        theFlooble = new Flooble();  // this is the only write to theFlooble
    }
}

public class SomeOtherClass {
    public void doWork() {
        while (true) { 
            // do some stuff...
            // use the Flooble, but only if it is ready
            if (floobleLoader.theFlooble != null) 
                doSomething(floobleLoader.theFlooble);
        }
    }
} 
#+END_SRC
***** Pattern #3 : Periodically published
One or many publications, (e.g update by sensor) and many reads.
Here we don't rely on previous values, and threads that read the values
Need to assume that the value can change at any time.
***** Pattern #4 : "Volatile bean"
[[id:3d1a87a2-9180-4767-94f4-f4c138eedab7][JavaBean]] classes that have only basic getters/setters and no logic in them are ok to use
for volatile variables.

Example:
#+BEGIN_SRC java
@ThreadSafe
public class Person {
    private volatile String firstName;
    private volatile String lastName;
    private volatile int age;

    public String getFirstName() { return firstName; }
    public String getLastName() { return lastName; }
    public int getAge() { return age; }

    public void setFirstName(String firstName) { 
        this.firstName = firstName;
    }

    public void setLastName(String lastName) { 
        this.lastName = lastName;
    }

    public void setAge(int age) { 
        this.age = age;
    }
}
#+END_SRC
***** (Adanced) Pattern # 5: The cheap read-write lock trick
Only use if performance is critical. It makes code messy and fragile.
Needs to be well documented.
Using two different locking mechanism.

For details, see [[http://www.ibm.com/developerworks/java/library/j-jtp06197/index.html#toc10][ibm source article]]
* @ Patterns and Terms 
** JavaBean           TERM__
:PROPERTIES:
:ID:       3d1a87a2-9180-4767-94f4-f4c138eedab7
:END:
JavaBean is a class that encapsulates many other classes.
[[http://en.wikipedia.org/wiki/JavaBeans][wiki ref]]
* @ Benchmarking 
** Timing between two bits of code 
#+BEGIN_SRC java
long start = System.currentTimeMillis();
//..
long end = System.currentTimeMillis();

//Outupt:
Long.toString(end - start)
#+END_SRC
* @ Bitwise Operations
Oracle Ref:
http://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html .

Examples:
http://www.tutorialspoint.com/java/java_bitwise_operators_examples.htm .

Understanding it tutorial:
http://code.tutsplus.com/articles/understanding-bitwise-operators--active-11301 .

#+BEGIN_SRC java
Symbol   Meaning  Example
---------------------- 
&        AND      a & b
|        OR       a | b
^        XOR      a ^ b
~        NEGATE   ~a
<<       shift,   a << 2   //shift by 2 bits to left.
>>       left bit depends on sign/extension
>>>      zero inserted in left-most pos.

Combined works:
int combined = 1 & 3 & 7;  //= 1 as that is the only common digit.

#+END_SRC


* Examples                                                               :EG:
** Threading
*** Wait and Notify - TickTock      [[elisp:(my/goto-parent)][parent]]  EG__
:PROPERTIES:
:ID:       24e26285-f47b-48b2-893f-8bbbfd8297b9
:END:
#+BEGIN_SRC java
//-------------------------------- TICK TOCK CLASS 
class TickTock {

    String state; // contains the state of the clock

    synchronized void tick(boolean running) {
        if (!running) { // stop the clock
            state = "ticked";
            notify(); // notify any waiting threads
            return;
        }

        System.out.print("Tick ");

        state = "ticked"; // set the current state to ticked

        notify(); // let tock() run
        try {
            while (!state.equals("tocked"))
                wait(); // wait for tock() to complete  //Note, you need to be in a synchronized block,
                                                        //otherwise you get a IllegalMonitorStateException error.
        } catch (InterruptedException exc) {
            System.out.println("Thread interrupted.");
        }
    }

    synchronized void tock(boolean running) {
        if (!running) { // stop the clock
            state = "tocked";
            notify(); // notify any waiting threads
            return;
        }

        System.out.println("Tock");

        state = "tocked"; // set the current state to tocked

        notify(); // let tick() run
        try {
            while (!state.equals("ticked"))
                wait(); // wait for tick to complete
        } catch (InterruptedException exc) {
            System.out.println("Thread interrupted.");
        }
    }
}

//---------------------------- MY THREAD CLASS 
class MyThread implements Runnable {
    Thread thrd;
    TickTock ttOb;

    // Construct a new thread.
    MyThread(String name, TickTock tt) {
      thrd = new Thread(this, name);
      ttOb = tt;
      thrd.start(); // start the thread
    }

    // Begin execution of new thread.
    @Override
    public void run() {

      if(thrd.getName().compareTo("Tick") == 0) {
        for(int i=0; i<5; i++)
            ttOb.tick(true);
        ttOb.tick(false);
      }
      else {
        for(int i=0; i<5; i++)
            ttOb.tock(true);
        ttOb.tock(false);
      }
    }
  }

//--------------------------- MAIN CLASS 
  public class TheMain {

    public static void main(String args[]) {
        TickTock tt = new TickTock();
        MyThread mt1 = new MyThread("Tick", tt);
        MyThread mt2 = new MyThread("Tock", tt);

        try {
            mt1.thrd.join();
            mt2.thrd.join();
        } catch (InterruptedException exc) {
            System.out.println("Main thread interrupted.");
        }
    }

}
#+END_SRC

